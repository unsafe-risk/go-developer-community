---
title: "# [GDC] Weekly Newsletter August 3rd"
datePublished: Sun Aug 18 2024 21:15:57 GMT+0000 (Coordinated Universal Time)
cuid: cm002gvx200030ajo1z0xebzw
slug: gdc-weekly-newsletter-august-3rd
tags: newsletter

---

> 본 아티클은 시험삼아 모두 Gemini Flash로 생성했습니다. 잘못된 부분은 [제 메일](snowmerak@outlook.com)로 알려주셨으면 합니다!

## gRPC over HTTP/3: 차세대 분산 시스템을 위한 혁신

### 요약

gRPC over HTTP/3는 분산 시스템의 성능과 효율성을 향상시키기 위한 새로운 기술입니다. gRPC는 이미 빠르고 효율적인 RPC 프레임워크로 알려져 있으며, HTTP/3는 최신 HTTP 프로토콜로서 낮은 지연 시간과 높은 성능을 제공합니다. 이 조합은 네트워크 환경이 악화되거나 복잡해지는 상황에서도 안정적인 통신을 보장하고 성능을 극대화합니다.

### 설명

gRPC는 Google에서 개발한 오픈 소스 RPC 프레임워크로, 효율적인 데이터 전송과 높은 성능을 제공합니다. HTTP/3는 HTTP의 차세대 버전으로, QUIC(Quick UDP Internet Connections) 프로토콜을 기반으로 합니다. QUIC은 UDP를 사용하여 TCP보다 더 빠르고 효율적인 데이터 전송을 제공하며, 동시에 여러 개의 스트림을 지원하여 멀티플렉싱을 가능하게 합니다.

### 토론

1. **gRPC와 HTTP/3의 시너지 효과:** gRPC의 높은 성능과 효율성에 HTTP/3의 낮은 지연 시간과 높은 성능이 더해져 분산 시스템의 성능이 크게 향상됩니다.
2. **네트워크 환경 변화에 대한 적응력:** HTTP/3는 혼잡한 네트워크 환경에서도 안정적인 통신을 보장하고, 다양한 네트워크 조건에 대한 적응력이 뛰어납니다.
3. **차세대 분산 시스템의 기반 기술:** gRPC over HTTP/3는 차세대 분산 시스템 구축을 위한 핵심 기술로, 향후 더욱 광범위하게 활용될 것으로 예상됩니다.

### 기능

- **빠른 데이터 전송:** QUIC 프로토콜을 사용하여 낮은 지연 시간과 높은 처리량을 제공합니다.
- **높은 효율성:** gRPC의 효율적인 데이터 전송 방식과 HTTP/3의 최적화된 프로토콜이 결합되어 높은 성능을 제공합니다.
- **안정적인 통신:** 혼잡한 네트워크 환경에서도 안정적인 데이터 전송을 보장합니다.
- **멀티플렉싱 지원:** 여러 개의 스트림을 동시에 처리하여 효율적인 통신을 가능하게 합니다.

### 사용법

#### 설치

gRPC over HTTP/3를 사용하려면 gRPC와 HTTP/3를 지원하는 라이브러리를 설치해야 합니다. 다양한 프로그래밍 언어에서 gRPC over HTTP/3를 지원하는 라이브러리가 제공됩니다.

#### gRPC over HTTP/3 사용

gRPC over HTTP/3를 사용하여 분산 시스템을 구축하려면 gRPC 서버와 클라이언트를 설정하고 HTTP/3를 사용하도록 구성해야 합니다. gRPC 라이브러리는 HTTP/3 지원을 위한 옵션을 제공하며, QUIC 프로토콜을 사용하도록 설정할 수 있습니다.

### 추천

gRPC over HTTP/3는 분산 시스템의 성능과 효율성을 향상시키기 위한 훌륭한 기술입니다. 특히 낮은 지연 시간과 높은 성능이 요구되는 분산 애플리케이션에 적합합니다.

### 외부 링크

- [gRPC 웹사이트](https://grpc.io/)
- [HTTP/3 웹사이트](https://http3.github.io/)

### 주의 사항

- **HTTP/3 지원:** 모든 네트워크 환경에서 HTTP/3가 지원되는 것은 아닙니다.
- **보안:** gRPC over HTTP/3는 보안에 대한 고려가 필요합니다. QUIC 프로토콜은 TLS/SSL을 사용하여 보안 연결을 제공합니다.

### 한국어 번역

이 글의 내용은 gRPC over HTTP/3에 대한 설명과 함께 Go 언어를 사용한 예제 코드를 제공합니다. HTTP/3가 gRPC 성능을 향상시키는 방법과 ConnectRPC 및 Buf와 같은 도구를 사용하여 HTTP/3를 gRPC 서비스에 통합하는 방법을 설명합니다. 

gRPC 생태계에서 HTTP/3 채택은 초기 단계에 있지만, 이 기술의 장점은 분명하며, 일부 라이브러리와 도구에서 이미 사용 가능합니다. 개발자는 이 기술을 탐구하고 고성능, 안전한 통신의 미래를 형성하는 데 기여할 수 있습니다. HTTP/3가 gRPC에 대한 광범위한 채택은 아직 시작 단계이지만, 서버와 클라이언트 구성 요소를 모두 제어할 수 있는 유연성이 있거나 브라우저 기반 클라이언트를 사용하는 경우, 이미 오늘날에도 유용한 사용 사례를 찾을 수 있습니다.## 2024년 프론트엔드 개발자를 위한 필수 도구 8가지

### Summary

이 글은 2024년 프론트엔드 개발자가 사용하기 좋은 8가지 도구를 소개합니다. 이 도구들은 개발 워크플로우를 간소화하고 생산성을 향상시키며, 고품질 웹 애플리케이션을 만드는 데 도움을 줄 수 있습니다.

### Description

이 글은 널리 알려진 Visual Studio Code나 React와 같은 도구 외에도 프론트엔드 개발자의 효율성을 크게 높일 수 있는 덜 알려진 강력한 도구와 웹사이트를 소개합니다. 각 도구는 웹 개발에서 필요한 다양한 작업을 지원하며, 기능, 사용법, 장점 및 단점을 자세히 설명합니다.

### Discussion

1. **프론트엔드 개발 트렌드 변화**: 이 글에서 소개된 도구는 현재 프론트엔드 개발 분야에서 인기 있는 도구이며, 새로운 기술과 함께 발전하고 있습니다. 
2. **개발 환경 구축의 중요성**: 효율적인 개발 환경을 구축하는 것은 생산성을 높이는 데 중요하며, 이 글에 소개된 도구는 개발 환경 설정을 용이하게 해줍니다.
3. **개발자의 취향과 프로젝트 특성에 맞는 도구 선택**: 이 글은 다양한 도구를 소개하지만, 개인의 선호도와 프로젝트 특성에 맞는 도구를 선택하는 것이 중요합니다.

### Features

- 2024년 프론트엔드 개발 환경을 향상시키는 데 도움이 되는 8가지 도구 소개
- 각 도구의 기능과 장점에 대한 설명
- 실제 사용 예시 및 팁 제공

### Usage

#### Installation

각 도구의 설치 방법은 공식 문서 또는 웹사이트를 참조하십시오.

#### Uiverse

Uiverse는 CSS와 Tailwind를 사용하여 만들어진 아름다운 UI 요소를 제공하는 오픈 소스 플랫폼입니다. 개발자는 사용자 지정 요소를 만들고 공유하며 프로젝트에 원활하게 사용할 수 있습니다. 커뮤니티 중심 접근 방식을 통해 독특한 디자인의 라이브러리가 지속적으로 확장되고 있어 개발자는 처음부터 시작하지 않고도 시각적으로 매력적인 구성 요소로 애플리케이션을 개선할 수 있습니다.

#### Figma Plugin: Motion

Motion은 Figma 플러그인으로, 애니메이션 생성을 간소화합니다. 이 도구를 사용하면 프론트엔드 개발자는 복잡한 코딩 없이 Figma 내에서 애니메이션을 디자인하고 프로토타입을 제작할 수 있습니다. Motion은 직관적인 인터페이스와 다양한 사용자 지정 가능한 애니메이션 사전 설정을 제공하여 정적 디자인에 생동감을 불어넣고 매력적인 사용자 경험을 만들 수 있습니다.

#### CSSFX

CSSFX는 웹 프로젝트에 쉽게 통합할 수 있는 사용할 준비가 된 CSS 애니메이션 모음을 제공합니다. 애니메이션은 코드 몇 줄만으로 간단하게 구현할 수 있습니다. CSSFX는 미묘한 호버 애니메이션부터 더 복잡한 전환까지 다양한 효과를 제공하여 개발자는 최소한의 노력으로 인터페이스에 상호 작용성과 광택을 더할 수 있습니다.

#### Frontend Mentor

Frontend Mentor는 실제 프로젝트를 통해 기술을 연마하고자 하는 프론트엔드 개발자를 위한 훌륭한 플랫폼입니다. 이 사이트는 디자인 파일과 자산을 갖춘 실제 클라이언트 브리핑을 모방하는 다양한 과제를 제공합니다. 개발자는 이러한 프로젝트를 수행하여 코딩 능력을 향상시키고 포트폴리오를 구축하고 동료 및 멘토 커뮤니티로부터 피드백을 받을 수 있습니다.

#### Greensock Animation Platform (GSAP)

GSAP는 고성능 애니메이션을 만드는 강력한 JavaScript 라이브러리입니다. GSAP는 부드러운 애니메이션, 복잡한 시퀀스 및 크로스 브라우저 호환성을 포함한 다양한 기능을 제공합니다. GSAP의 유연성과 사용 편의성은 웹 애플리케이션에 동적 애니메이션을 추가하고자 하는 개발자에게 귀중한 도구입니다. GSAP의 강력한 문서 및 활성 커뮤니티 지원은 GSAP의 매력을 더욱 높입니다.

#### CodePen

CodePen은 프론트엔드 개발자가 자신의 작업을 보여주고, 코드를 실험하고, 영감을 얻을 수 있는 소셜 개발 환경입니다. 개발자는 "펜"(작은 코드 스니펫)을 만들고 커뮤니티와 공유하여 피드백을 받고 다른 사람과 협력할 수 있습니다. CodePen의 실시간 미리보기 기능은 실시간 테스트 및 디버깅을 허용하여 학습과 실험을 위한 훌륭한 플랫폼입니다.

#### Polypane

Polypane은 웹 개발자와 디자이너를 위해 특별히 설계된 브라우저입니다. 동기화 스크롤, 반응형 미리보기 및 접근성 검사와 같은 기능을 제공합니다. Polypane을 사용하면 개발자는 여러 장치 및 화면 크기에서 동시에 웹사이트를 볼 수 있으므로 일관성과 접근성을 보장하는 데 도움이 됩니다. 내장 개발자 도구와 디버깅 옵션은 개발 프로세스를 더욱 간소화합니다.

#### Can I Use

Can I Use는 프론트엔드 개발자가 다양한 브라우저와 장치에서 웹 기능의 호환성을 확인하는 데 필수적인 리소스입니다. 이 도구는 다양한 HTML, CSS 및 JavaScript 기능의 지원 상태에 대한 최신 정보를 제공하여 개발자가 어떤 기술을 사용할지에 대한 정보에 입각한 결정을 내리는 데 도움을 줍니다. 이 사이트는 또한 자세한 사용 통계와 브라우저별 특징에 대한 정보를 제공합니다.

### Recommendation

본 글에서 소개된 도구를 활용하여 프론트엔드 개발을 더욱 효율적으로 진행하고 생산성을 높이세요. 이 도구들은 웹 개발 과정을 간소화하고, 혁신적인 기능을 활용하여 고품질의 웹 애플리케이션을 개발하는 데 도움을 줄 수 있습니다. 

### External Links

- [Uiverse](https://uiverse.io/)
- [Figma Plugin: Motion](https://motionplugin.com/)
- [CSSFX](https://cssfx.netlify.app/)
- [Frontend Mentor](https://www.frontendmentor.io/)
- [Greensock Animation Platform (GSAP)](https://gsap.com/)
- [CodePen](https://codepen.io/)
- [Polypane](https://polypane.app/)
- [Can I Use](https://caniuse.com/)

### Caution

- 각 도구의 사용법은 공식 문서를 참조하는 것이 좋습니다.
- 특정 도구의 버전별 차이점을 확인하고 적절한 버전을 사용하십시오.
- 도구를 사용하기 전에 라이선스 및 사용 조건을 확인하십시오.
- 보안 및 개인 정보 보호에 유의하여 도구를 사용하십시오.

## 시스템 설계 및 소프트웨어 아키텍처를 위한 필수 백서 40선

### 요약

이 글은 시스템 설계 인터뷰를 준비하는 개발자를 위한 필수 백서 40선을 소개합니다. Google, AWS 등 유명 IT 기업에서 작성한 이 백서들은 복잡한 실제 시스템의 아키텍처를 이해하는 데 도움이 되는 심층적인 기술 정보, 실제 사례 연구 및 모범 사례를 제공합니다. 분산 시스템의 기본 개념에서 최신 기술 트렌드까지 다루는 이 백서들은 인터뷰 준비는 물론, 개발자로서의 역량 강화에도 큰 도움이 될 것입니다.

### 설명

시스템 설계 및 소프트웨어 아키텍처 분야는 빠르게 진화하고 있으며, 이에 따라 이 분야에 대한 이해도는 개발자의 성공을 위한 필수 요소가 되었습니다. 백서는 이러한 분야에 대한 깊이 있는 지식을 제공하는 귀중한 자료로, 이 글에서 소개되는 백서들은 다양한 주제를 다루며, 시스템 설계, 소프트웨어 아키텍처 및 인터뷰 준비에 도움이 되는 다양한 관점을 제공합니다.

### 논의

1. **다양한 주제 포괄:** 백서들은 분산 시스템, 데이터베이스, 네트워킹, 보안, 클라우드 컴퓨팅, 마이크로서비스, 빅 데이터 등 다양한 주제를 다루며, 시스템 설계 및 소프트웨어 아키텍처에 대한 종합적인 이해를 돕습니다.
2. **실제 환경에서의 경험 공유:** 유명 IT 기업들의 전문가들이 작성한 백서들은 실제 개발 환경에서 얻은 경험과 노하우를 담고 있어, 실무에 바로 적용할 수 있는 지식을 제공합니다.
3. **최신 기술 트렌드 반영:** 백서들은 클라우드 컴퓨팅, 마이크로서비스, 빅 데이터 등 최신 기술 트렌드를 반영하여, 개발자들이 최신 기술에 대한 이해를 높이는 데 도움을 줄 수 있습니다.

### 기능

- 시스템 설계 및 소프트웨어 아키텍처 관련 다양한 주제 다루기
- 분산 시스템, 데이터베이스, 네트워킹, 보안 등 다양한 기술적 주제 다루기
- 클라우드 컴퓨팅, 마이크로서비스, 빅 데이터 등 최신 기술 트렌드 소개
- 실제 개발 환경에서 얻은 경험과 노하우 공유
- 시스템 설계 인터뷰 준비를 위한 필수 지식 제공

### 추천

시스템 설계 및 소프트웨어 아키텍처에 관심있는 개발자, 아키텍트, 혹은 관련 분야를 공부하는 학생들에게 추천합니다. 특히, 시스템 설계 인터뷰를 준비하는 개발자들에게는 필독 자료입니다.

### 외부 링크

- [원본 백서 목록](https://medium.com/javarevisited/40-must-read-white-papers-to-learn-system-design-and-software-architecture-775c4197f9c8)

### 주의

- 백서들은 다양한 기술 수준을 가진 독자를 위해 작성되었으므로, 이해하기 어려운 부분이 있을 수 있습니다.
- 백서 내용은 기술 발전에 따라 변경될 수 있습니다. 
## SEB 타이거 스타일: 간단한 이벤트 브로커의 성능 개선

### 요약

이 글은 TigerBeetle의 Tiger Style 코딩 스타일을 적용하여 간단한 이벤트 브로커인 Seb의 성능을 개선하는 과정을 설명합니다. Tiger Style의 핵심 원칙인 "Stop Everything, But" 방식과 성능 최적화 전략을 통해 Seb의 쓰기 성능을 향상시켰습니다.

### 설명

SEB는 빠르고 안전한 이벤트 브로커를 목표로 개발 중인 프로젝트입니다. TigerBeetle의 Tiger Style은 효율적인 코드 작성을 위한 방법론으로, 특히 성능 측면에서 많은 영향을 주었습니다. 이 글에서는 Tiger Style을 적용하여 Seb의 쓰기 경로에서 발생하는 메모리 할당 및 가비지 수집 문제를 해결하고, 성능을 향상시키는 과정을 자세히 보여줍니다.

### 토론

1. **Tiger Style의 적용:**
    - "Stop Everything, But" 원칙을 통해 코드 리뷰 시 문제 발생 시 즉시 해결
    - 네트워크, 디스크, 메모리, CPU 리소스 활용 최적화
    - 메모리 할당 최소화 및 성능 향상
    - 데이터 변환 최소화를 통한 효율성 증대

2. **프로파일링의 중요성:**
    - 코드 최적화를 위한 필수적인 단계
    - Go의 pprof 도구를 활용한 시스템적 측정
    - Flame Graph를 통한 메모리 할당 및 가비지 수집 문제 분석

3. **성능 개선 결과:**
    - Tiger Style의 원칙을 적용하여 Seb의 쓰기 성능이 두 배 가까이 향상
    - 메모리 할당 최소화 및 가비지 수집 부담 감소
    - 효과적인 버퍼 풀 활용을 통한 성능 향상


### 기능

- **Stop Everything, But:** 코드 리뷰 중 문제 발생 시 즉시 해결
- **성능 프로파일링:** Go의 pprof 도구 활용
- **Flame Graph 분석:** 가비지 수집 및 메모리 할당 문제 분석
- **메모리 할당 최소화:** 데이터 변환 최소화 및 버퍼 풀 활용


### 사용법

#### 설치

Tiger Style은 별도의 설치가 필요하지 않으며, 코드 작성 시 코딩 스타일 및 원칙을 따릅니다.

#### SEB 타이거 스타일 적용

1. 코드 리뷰 중 문제 발생 시 "Stop Everything, But" 원칙에 따라 즉시 문제를 해결합니다.
2. Go의 pprof 도구를 사용하여 프로파일링을 수행하고 Flame Graph를 통해 메모리 할당 및 가비지 수집 문제를 분석합니다.
3. 데이터 변환 최소화 및 버퍼 풀을 활용하여 메모리 할당을 줄이고, 성능을 향상시킵니다.


### 권장 사항

- Tiger Style은 코드 품질 및 성능 향상에 큰 도움이 될 수 있습니다.
- 프로파일링을 통해 코드의 문제점을 파악하고, 효과적인 최적화 전략을 수립하는 것이 중요합니다.
- 데이터 변환 및 메모리 할당 최소화를 위한 노력은 성능 향상에 큰 영향을 미칩니다.

### 외부 링크

- [TigerBeetle 웹사이트](https://tigerbeetle.com/)
- [Tiger Style 문서](https://github.com/tigerbeetle/tigerbeetle/blob/main/docs/TIGER_STYLE.md)
- [Seb 저장소](https://github.com/micvbang/simple-event-broker)

### 주의 사항

- Tiger Style은 코드 작성에 많은 노력을 요구할 수 있습니다.
- 성능 최적화는 시스템의 복잡성을 증가시킬 수 있으며, 신중한 접근이 필요합니다.
- 프로파일링 및 최적화 과정은 시간이 많이 소요될 수 있습니다.

## EP118: 데이터베이스 락의 차이점

### Summary

이 글은 데이터베이스 락의 종류와 각 락의 차이점을 설명하며, API 디자인에서의 페이징 기법, MVC, MVP, MVVM, MVVM-C, VIPER 아키텍처 패턴의 차이점, URL을 브라우저에 입력했을 때 일어나는 일, QR 코드 스캔을 통한 디지털 지갑 결제 방식 등 다양한 시스템 디자인 관련 주제를 다룹니다.

### Description

데이터베이스 락은 동시에 데이터에 접근하는 여러 트랜잭션을 제어하여 데이터 무결성과 일관성을 유지하는 데 중요한 역할을 합니다. 이 글은 데이터베이스 락의 다양한 종류와 각 락의 특징, 장단점, 사용 시나리오를 설명합니다. 또한, API 디자인에서 효율적인 데이터 처리를 위한 페이징 기법과 앱 개발에 널리 사용되는 다양한 아키텍처 패턴을 비교 분석합니다. 

### Discussion

1. **데이터베이스 락의 종류:** 
    - 공유 락 (S 락): 여러 트랜잭션이 동시에 데이터를 읽을 수 있지만 수정은 불가능합니다. 다른 트랜잭션도 같은 리소스에 공유 락을 얻을 수 있습니다.
    - 배타 락 (X 락): 한 트랜잭션이 데이터를 읽고 수정할 수 있습니다. 배타 락이 걸려 있는 동안 다른 트랜잭션은 같은 리소스에 어떤 종류의 락도 얻을 수 없습니다.
    - 업데이트 락 (U 락): 트랜잭션이 데이터를 업데이트하려고 할 때 데드락을 방지하기 위해 사용됩니다.
    - 스키마 락: 데이터베이스 객체의 구조를 보호하기 위해 사용됩니다.
    - 벌크 업데이트 락 (BU 락): 벌크 삽입 작업 중에 필요한 락의 수를 줄여 성능을 향상시키기 위해 사용됩니다.
    - 키 범위 락: 인덱싱된 데이터에서 팬텀 읽기 (트랜잭션이 이미 읽은 범위에 새로운 행을 삽입하는 경우)를 방지하기 위해 사용됩니다.
    - 행 레벨 락: 테이블의 특정 행을 락하여 다른 행을 동시에 접근할 수 있도록 합니다.
    - 페이지 레벨 락: 데이터베이스의 특정 페이지 (고정 크기의 데이터 블록)를 락합니다.
    - 테이블 레벨 락: 전체 테이블을 락합니다. 구현이 간단하지만 동시성을 크게 제한할 수 있습니다.

2. **API 디자인에서의 페이징 기법:** 
    - 오프셋 기반 페이징: 오프셋과 리미트 매개변수를 사용하여 시작 지점과 반환할 레코드 수를 정의합니다.
        - 장점: 구현과 이해가 간단합니다.
        - 단점: 큰 오프셋에서는 성능이 저하될 수 있습니다.
    - 커서 기반 페이징: 커서 (고유 식별자)를 사용하여 데이터셋의 위치를 ​​표시합니다. 커서는 일반적으로 특정 레코드를 가리키는 인코딩된 문자열입니다.
        - 장점: 큰 데이터셋에 효율적이며 건너뛴 레코드를 스캔할 필요가 없습니다.
        - 단점: 구현과 이해가 다소 복잡합니다.
    - 페이지 기반 페이징: 페이지 번호와 각 페이지의 크기를 지정합니다.
        - 장점: 구현 및 사용이 쉽습니다.
        - 단점: 큰 페이지 번호에서는 오프셋 기반 페이징과 유사한 성능 문제가 발생할 수 있습니다.
    - 키셋 기반 페이징: 종종 기본 키 또는 다른 인덱싱된 열인 키를 사용하여 데이터셋을 필터링합니다.
        - 장점: 큰 데이터셋에 효율적이며 큰 오프셋과 관련된 성능 문제를 방지합니다.
        - 단점: 고유하고 인덱싱된 키가 필요하며 구현이 복잡할 수 있습니다.
    - 시간 기반 페이징: 타임스탬프 또는 날짜를 사용하여 레코드를 페이징합니다.
        - 장점: 시간순으로 정렬된 데이터셋에 유용하며 새 레코드가 추가되더라도 레코드가 누락되지 않습니다.
        - 단점: 안정적이고 일관된 타임스탬프가 필요합니다.
    - 하이브리드 페이징: 여러 페이징 기법을 결합하여 강점을 활용합니다.
        - 장점: 복잡한 데이터셋에 대해 최상의 성능과 유연성을 제공할 수 있습니다.
        - 단점: 구현이 더 복잡하며 주의 깊은 설계가 필요합니다.

3. **MVC, MVP, MVVM, MVVM-C, VIPER 아키텍처 패턴 비교:** 
    - MVC (Model-View-Controller): 가장 오래된 패턴으로, 컨트롤러가 뷰와 모델 사이의 중개자 역할을 합니다.
    - MVP (Model-View-Presenter): 컨트롤러 대신 프레젠터를 사용하여 뷰의 로직을 처리합니다.
    - MVVM (Model-View-ViewModel): 뷰 모델을 사용하여 뷰의 데이터 바인딩을 간소화합니다.
    - MVVM-C (Model-View-ViewModel-Coordinator): 코디네이터를 추가하여 뷰 간의 이동과 데이터 흐름을 관리합니다.
    - VIPER (View-Interactor-Presenter-Entity-Router): 뷰와 모델 사이에 다섯 개의 구성 요소를 사용하여 역할을 명확히 분리합니다.

4. **URL을 브라우저에 입력했을 때 일어나는 일:** 
    - DNS 조회: 도메인 이름을 IP 주소로 변환합니다.
    - TCP 연결: 서버와의 TCP 연결을 설정합니다.
    - HTTP 요청: 서버로 HTTP 요청을 보냅니다.
    - 서버 응답: 서버는 HTTP 응답을 보냅니다.
    - HTML 렌더링: 브라우저는 HTML 콘텐츠를 렌더링합니다.

5. **QR 코드 스캔을 통한 디지털 지갑 결제:** 
    - QR 코드 생성: 결제 정보를 포함하는 QR 코드를 생성합니다.
    - QR 코드 스캔: 디지털 지갑 앱을 사용하여 QR 코드를 스캔합니다.
    - 결제 확인: 결제 금액을 확인하고 결제 버튼을 클릭합니다.
    - PSP 통신: 디지털 지갑 앱이 PSP (Payment Service Provider)에 결제 요청을 보냅니다.
    - 결제 완료: PSP가 결제를 처리하고 디지털 지갑 앱과 판매자에게 성공 메시지를 보냅니다.

### Features

- 다양한 데이터베이스 락 종류에 대한 자세한 설명
- API 디자인에서의 다양한 페이징 기법 비교
- 앱 개발에서 널리 사용되는 아키텍처 패턴의 차이점 비교
- URL 입력, QR 코드 결제 등 실제 시스템 디자인 관련 주제 설명

### Recommendation

이 글은 개발자들이 데이터베이스 락, API 디자인, 아키텍처 패턴 등 시스템 디자인의 기본 개념과 실제 적용 사례를 이해하는 데 도움을 줄 수 있습니다. 특히, 페이징 기법과 아키텍처 패턴은 개발 프로젝트에서 적절한 선택을 하는 데 중요한 역할을 하므로, 해당 내용에 대한 이해가 필요합니다.

### External Links

- [데이터베이스 락 관련 문서](https://en.wikipedia.org/wiki/Database_locking)
- [API 페이징 관련 문서](https://www.freecodecamp.org/news/pagination-in-api-design/)
- [MVC, MVP, MVVM 아키텍처 패턴 비교](https://www.tutorialspoint.com/design_pattern/mvc_pattern.htm)
- [VIPER 아키텍처 패턴](https://github.com/objcio/articles/blob/master/VIPER.md)
- [QR 코드 결제 관련 문서](https://en.wikipedia.org/wiki/QR_code_payment)

### Caution

- 데이터베이스 락은 개발 프로젝트의 특성과 요구사항에 따라 적절하게 선택하고 적용해야 합니다. 
- 페이징 기법은 데이터셋의 크기, 데이터 유형, 성능 요구사항 등을 고려하여 적절한 방식을 선택해야 합니다.
- 아키텍처 패턴은 개발 프로젝트의 규모, 복잡도, 유지보수성 등을 고려하여 선택해야 합니다.
- 시스템 디자인은 다양한 요소를 종합적으로 고려해야 하므로, 다양한 자료를 참고하고 숙련된 개발자의 조언을 구하는 것이 좋습니다.
## Go 1.23의 새로운 기능: 반복자와 reflect.Value.Seq

### Summary

이 글은 Go 1.23 릴리즈 후보에서 새롭게 추가된 반복자와 `reflect.Value.Seq` 메서드에 대해 설명합니다. Go 1.23에서 새롭게 추가된 제네릭 사용자 지정 반복 함수의 작동 방식과 `reflect` 패키지에 추가된 새로운 메서드의 뒷이야기를 다룹니다.

### Description

Go 1.23 릴리즈 후보 버전에서는 제네릭 사용자 지정 반복 함수가 새롭게 추가되었습니다. 이 반복자를 사용하면 특정 데이터 타입의 값을 순회할 수 있습니다. 또한 `reflect` 패키지에는 `reflect.Value.Seq`, `reflect.Value.Seq2`, `reflect.Type.CanSeq`, `reflect.Type.CanSeq2` 와 같은 새로운 메서드가 추가되었습니다.

### Discussion

1. **Go 1.23의 반복자**: Go 1.23에서는 제네릭을 사용하여 사용자 지정 반복 함수를 만들 수 있게 되었습니다. 이 반복 함수는 `iter.Seq` 타입을 반환하며, 이는 `func(yield func(V) bool)`과 동일합니다. 여기서 `V`는 임의의 타입입니다. 반복자는 콜백을 받아 실행합니다. 콜백은 반복된 값 스트림에서 값을 받아 `true` 또는 `false`를 반환합니다. `true`를 반환하면 반복자가 시퀀스의 다음 값을 반환해야 합니다. `false`를 반환하면 반복자는 필요한 정리 작업을 수행하고 반복을 중지해야 합니다.
2. **`reflect` 패키지의 새로운 메서드**: `reflect.Value.Seq` 메서드는 `reflect.Value` 타입의 값을 반복 처리하는 `iter.Seq[Value]`를 반환합니다. `reflect.Type.CanSeq` 메서드는 타입이 반복자로 사용될 수 있는지 여부를 나타냅니다.
3. **새로운 메서드의 유용성**:  `reflect` 패키지의 새로운 메서드를 사용하면 반사 기능을 통해 데이터 타입에 대한 제한 없이 값을 반복 처리하고 타입을 확인할 수 있습니다.

### Features

- Go 1.23에서 새롭게 추가된 제네릭 사용자 지정 반복 함수
- `reflect` 패키지에 추가된 새로운 메서드(`reflect.Value.Seq`, `reflect.Value.Seq2`, `reflect.Type.CanSeq`, `reflect.Type.CanSeq2`)
- 반사 기능을 통해 다양한 타입의 값을 반복 처리하고 타입을 확인

### Usage

#### 값 시퀀스 반복 처리 및 타입 확인

```go
package main

import (
	"fmt"
	"reflect"
)

func main() {
	values := []interface{}{1, "hello", true, 3.14}

	for i := 0; i < reflect.ValueOf(values).Len(); i++ {
		value := reflect.ValueOf(values).Index(i)
		fmt.Printf("Value %d: Type = %T, Value = %v\n", i, value.Interface(), value.Interface())
	}
}
```

#### 값 시퀀스 변환

```go
package main

import (
	"fmt"
	"reflect"
)

func main() {
	values := []interface{}{1, "hello", true, 3.14}

	// 값 시퀀스를 문자열 슬라이스로 변환
	var stringValues []string
	for i := 0; i < reflect.ValueOf(values).Len(); i++ {
		value := reflect.ValueOf(values).Index(i)
		stringValues = append(stringValues, fmt.Sprintf("%v", value.Interface()))
	}

	fmt.Println(stringValues)
}
```

### Recommendation

`reflect` 패키지는 강력한 도구이지만 사용에 주의해야 합니다. 가능하면 `reflect` 패키지 대신 타입 안전성을 보장하는 다른 방법을 사용하는 것이 좋습니다.

### External Links

- [Go 언어 문서 - reflect 패키지](https://pkg.go.dev/reflect)
- [Go 언어 블로그 - reflect 패키지 사용하기](https://blog.golang.org/go-reflect-metadata)

### Caution

- `reflect` 패키지를 사용하는 코드는 일반적으로 가독성이 떨어지고 성능이 저하될 수 있습니다.
- `reflect` 패키지를 사용하여 타입을 변환할 때 타입 안전성을 유지하는 데 주의해야 합니다.
- `reflect` 패키지는 실행 시점에 작동하기 때문에 컴파일 타임 오류를 잡아낼 수 없습니다.
## Cogent Core: 강력하고 빠르고 우아한 2D 및 3D 앱 개발 프레임워크

### 요약

Cogent Core는 macOS, Windows, Linux, iOS, Android 및 웹에서 실행되는 강력하고 빠르며 우아한 2D 및 3D 앱을 구축하기 위한 무료 오픈 소스 프레임워크입니다. 단일 Go 코드베이스를 사용하여 모든 플랫폼에서 실행할 수 있으므로 한 번 코딩하고 모든 곳에서 실행할 수 있습니다.

### 설명

Cogent Core는 다양한 플랫폼에서 실행되는 고성능 애플리케이션을 쉽게 개발할 수 있도록 도와주는 Go 기반의 크로스 플랫폼 프레임워크입니다. 이는 데스크톱, 모바일 및 웹 애플리케이션을 구축하기 위한 통합된 솔루션을 제공하며, 사용자 인터페이스 요소, 2D 및 3D 그래픽, 게임 개발 도구를 포함한 광범위한 기능을 제공합니다.

### 논의

1. **크로스 플랫폼 개발**: Cogent Core를 사용하면 단일 코드베이스를 사용하여 여러 플랫폼을 타겟팅할 수 있습니다. 이는 개발 시간과 노력을 절약하고 코드 재사용을 촉진합니다.
2. **고성능**: Cogent Core는 고성능 Go 언어를 기반으로 하여 리소스 집약적인 작업에도 효율적인 성능을 제공합니다.
3. **우아한 사용자 인터페이스**: Cogent Core는 매력적이고 사용자 친화적인 사용자 인터페이스를 구축할 수 있는 다양한 UI 요소를 제공합니다.

### 기능

- macOS, Windows, Linux, iOS, Android 및 웹 지원
- 2D 및 3D 그래픽 렌더링
- 사용자 인터페이스 요소(버튼, 텍스트 필드, 목록 상자 등)
- 게임 개발 도구(입력 처리, 물리 엔진 등)
- 네트워킹 및 통신 기능
- 데이터베이스 통합
- 파일 시스템 액세스
- 외부 라이브러리 및 패키지 지원

### 사용법

#### 설치

Cogent Core는 Go 언어로 작성되었으며 Go 환경이 설치되어 있어야 합니다. 설치 방법은 Cogent Core 공식 문서를 참조하십시오.

#### 애플리케이션 개발

Cogent Core는 간단한 API를 제공하여 애플리케이션을 구축합니다. 다음은 간단한 Cogent Core 애플리케이션의 예입니다.

```go
package main

import (
	"fmt"

	"cogentcore.org/core"
)

func main() {
	// Cogent Core 초기화
	app := core.NewApp()

	// 창 생성
	window := app.NewWindow("Cogent Core 앱", 800, 600)

	// UI 요소 생성
	label := window.NewLabel("안녕하세요, Cogent Core!")

	// 창에 UI 요소 추가
	window.AddChild(label)

	// 애플리케이션 실행
	app.Run()
}
```

### 권장 사항

Cogent Core는 다양한 플랫폼에서 실행되는 고성능 애플리케이션을 빠르게 개발하고자 하는 개발자에게 권장됩니다. 특히, 크로스 플랫폼 게임, 데스크톱 애플리케이션 또는 웹 기반 애플리케이션을 구축하는 경우 유용합니다.

### 외부 링크

- [Cogent Core 공식 문서](https://cogentcore.org/core)
- [GitHub 저장소](https://github.com/cogentcore/core)

### 주의 사항

- Cogent Core는 Go 언어에 대한 기본적인 지식이 필요합니다.
- 일부 기능은 특정 플랫폼에서만 지원될 수 있습니다. 자세한 내용은 Cogent Core 공식 문서를 참조하십시오.
- Cogent Core는 활발하게 개발 중이며, 버전 업데이트에 따라 API 및 기능이 변경될 수 있습니다.
## guycipher/btree: Go로 작성된 임베디드, 동시성 지원 디스크 B-트리

### Summary

guycipher/btree 저장소는 Go로 작성된 임베디드, 동시성 지원 디스크 B-트리 구현입니다. 빠른 검색과 많은 값을 가진 키에 최적화되어 있습니다.

### Description

이 저장소는 B-트리의 기본적인 개념과 구현 방법을 보여주며, Go 언어를 사용하여 구현된 B-트리 라이브러리를 제공합니다. 이 저장소에서 제공되는 B-트리 라이브러리는 디스크 기반으로 저장되며, 동시성을 지원하기 때문에 여러 고루틴에서 안전하게 사용할 수 있습니다.

### Discussion

1. **장점:** B-트리는 대량의 데이터를 효율적으로 저장하고 검색할 수 있으며, 동시성 지원을 통해 여러 고루틴에서 안전하게 사용할 수 있습니다.
2. **단점:** 아직 프로덕션 환경에서 사용하기에는 완벽하지 않으며, 추가적인 테스트와 최적화가 필요합니다.
3. **적용:** 데이터베이스, 파일 시스템, 인덱싱 엔진 등 다양한 분야에 활용될 수 있습니다.

### Features

- 사용하기 쉬운 API (Put, Get, Delete, Remove, Iterator, Range)
- 노드 레벨 락을 사용한 세밀한 동시성 제어
- 디스크 기반 저장
- 범위 쿼리 지원
- 이터레이터 지원
- 여러 값을 가진 키 지원

### Usage

#### Installation

```bash
go get github.com/guycipher/btree
```

#### B-트리 사용 예시

```go
package main

import (
    "fmt"
    "github.com/guycipher/btree"
)

func main() {
    bt, err := btree.Open("path/to/btree.db", 0644, 3)
    if err != nil {
        // 오류 처리
    }
    defer bt.Close()

    // 키-값 쌍 삽입
    err = bt.Put("key", "value")
    if err != nil {
        // 오류 처리
    }

    // 값 가져오기
    values, err := bt.Get("key")
    if err != nil {
        // 오류 처리
    }
    fmt.Println(values)

    // 키 삭제
    err = bt.Delete("key")
    if err != nil {
        // 오류 처리
    }
}
```

### Recommendation

Go 언어를 사용하여 디스크 기반 데이터 저장 및 검색 기능을 구현해야 하는 개발자에게 추천합니다. 특히 동시성 지원이 필요한 경우에 유용합니다.

### External Links

- [guycipher/btree 저장소](https://github.com/guycipher/btree)
- [B-트리 위키피디아](https://ko.wikipedia.org/wiki/B-%ED%8A%B8%EB%A6%AC)
- [B-트리 - GeeksforGeeks](https://www.geeksforgeeks.org/b-tree-set-1-introduction/)

### Caution

- 아직 프로덕션 환경에서 사용하기에는 완벽하지 않습니다.
- B-트리 구현은 복잡하며, 다양한 조건과 최적화를 고려해야 합니다.
## Go-Tika: Apache Tika를 사용하는 Go 패키지

### Summary

Go-Tika는 Apache Tika 서버 API를 사용하는 Go 클라이언트 라이브러리 및 명령줄 유틸리티입니다. Apache Tika는 다양한 파일 형식의 콘텐츠 및 메타데이터를 추출하는 데 널리 사용되는 라이브러리입니다. Go-Tika를 사용하면 Go 개발자는 Go 애플리케이션에서 Tika의 강력한 기능을 활용하여 파일을 분석하고 콘텐츠를 추출할 수 있습니다.

### Description

Go-Tika는 Go 언어로 작성되었으며 Apache Tika 서버 API와 통신하여 다양한 파일 형식을 처리할 수 있습니다. 이 패키지는 파일의 텍스트 콘텐츠 및 메타데이터를 추출하는 기능을 제공합니다. Go-Tika는 또한 Apache Tika 서버를 다운로드하고 백그라운드에서 실행할 수 있는 명령줄 유틸리티를 포함합니다.

### Discussion

1. Go-Tika는 Go 언어로 구현된 Tika 라이브러리로, Go 애플리케이션에서 Tika 기능을 쉽게 사용할 수 있다는 장점이 있습니다.
2. 다양한 파일 형식을 지원하며, 텍스트 추출, 메타데이터 분석 등 다양한 작업을 수행할 수 있습니다.
3. Apache Tika의 강력한 기능을 활용하여 다양한 애플리케이션에서 파일 분석 및 정보 추출 기능을 구현할 수 있습니다.

### Features

- Go 언어로 작성되어 Go 애플리케이션과의 호환성이 뛰어납니다.
- 다양한 파일 형식을 지원합니다.
- 텍스트 추출, 메타데이터 분석 등 다양한 기능을 제공합니다.
- Apache Tika 서버를 다운로드하고 백그라운드에서 실행하는 명령줄 유틸리티를 포함합니다.

### Usage

#### 설치

```bash
go get github.com/google/go-tika
```

#### 파일 분석 및 텍스트 추출

```go
package main

import (
	"fmt"

	"github.com/google/go-tika"
)

func main() {
	// Tika 클라이언트 생성
	client, err := tika.NewClient("http://localhost:9998")
	if err != nil {
		panic(err)
	}
	defer client.Close()

	// 파일 분석
	content, err := client.Text("path/to/file.pdf")
	if err != nil {
		panic(err)
	}

	// 텍스트 출력
	fmt.Println(content)
}
```

#### 메타데이터 추출

```go
package main

import (
	"fmt"

	"github.com/google/go-tika"
)

func main() {
	// Tika 클라이언트 생성
	client, err := tika.NewClient("http://localhost:9998")
	if err != nil {
		panic(err)
	}
	defer client.Close()

	// 메타데이터 추출
	metadata, err := client.Metadata("path/to/file.pdf")
	if err != nil {
		panic(err)
	}

	// 메타데이터 출력
	for key, value := range metadata {
		fmt.Printf("%s: %s\n", key, value)
	}
}
```

### Recommendation

Go 언어로 파일 분석 및 정보 추출 기능을 구현해야 하는 경우 Go-Tika를 사용하는 것을 추천합니다. Apache Tika의 강력한 기능을 활용하여 다양한 파일 형식을 분석하고 콘텐츠를 추출할 수 있습니다.

### External Links

- [Go-Tika GitHub Repository](https://github.com/google/go-tika)
- [Apache Tika 공식 웹사이트](https://tika.apache.org/)

### Caution

- Go-Tika는 Apache Tika 라이브러리에 의존합니다. 따라서 Apache Tika가 설치되어 있어야 합니다.
- Go-Tika는 Go 언어로 작성되었으므로 Go 프로그래밍 지식이 필요합니다.
## SWIG: C/C++ 코드를 다양한 언어로 래핑하는 도구

### Summary

SWIG(Simplified Wrapper and Interface Generator)는 C/C++ 코드를 다른 프로그래밍 언어에서 사용할 수 있도록 래핑하는 도구입니다. SWIG를 사용하면 Python, Java, Perl, Ruby, PHP, Lua, Tcl, Javascript, C#, Go, D, Ocaml, R, Scilab, Scheme, Octave, Modula-3, and Pike와 같은 다양한 언어로 C/C++ 코드를 래핑할 수 있습니다.

### Description

SWIG는 C/C++ 코드의 인터페이스를 분석하여 대상 언어에 맞는 바인딩을 자동으로 생성하는 툴입니다. 개발자는 SWIG 인터페이스 정의 언어(IDL)를 사용하여 C/C++ 코드의 인터페이스를 정의하고 SWIG를 통해 IDL 파일을 컴파일하여 바인딩 코드를 생성합니다. 이를 통해 개발자는 여러 언어에서 C/C++ 코드를 재사용할 수 있게 됩니다. 

### Features

- **다양한 언어 지원:** Python, Java, Perl, Ruby 등 다양한 언어를 지원합니다.
- **자동 바인딩 생성:** C/C++ 코드의 인터페이스를 분석하여 대상 언어에 맞는 바인딩을 자동으로 생성합니다.
- **IDL 사용:** 인터페이스 정의 언어(IDL)를 사용하여 래핑을 위한 코드를 간편하게 생성합니다.
- **C/C++ 확장:** 스크립팅 언어를 사용하여 C/C++ 프로그램을 확장할 수 있습니다.

### Usage

#### Installation

SWIG는 공식 웹사이트에서 소스 코드를 다운로드하여 컴파일하거나 패키지 관리자를 사용하여 설치할 수 있습니다.

#### SWIG 사용하기

1. C/C++ 코드의 인터페이스를 SWIG IDL(Interface Definition Language)를 사용하여 정의합니다.
2. SWIG를 사용하여 IDL 파일을 컴파일하여 바인딩 코드를 생성합니다.
3. 생성된 바인딩 코드를 대상 언어의 프로젝트에 포함하여 사용합니다.

#### 예제

```c++
// example.h
int add(int a, int b);
```

```swig
%module example
%{
#include "example.h"
%}
int add(int a, int b);
```

```python
# example.py
import example
print(example.add(1, 2))
```

### Recommendation

SWIG는 C/C++ 코드를 다른 언어에서 사용하려는 개발자에게 유용한 도구입니다. SWIG는 복잡한 코드를 래핑하는 데 도움이 되며 다양한 언어를 지원하여 개발자가 C/C++ 코드를 재사용할 수 있도록 지원합니다.

### External Links

- [SWIG 공식 웹사이트](https://swig.org/)
- [SWIG 튜토리얼](https://swig.org/tutorial.html)
- [SWIG 위키](https://github.com/swig/swig/wiki)

### Caution

- 복잡한 C/C++ 코드를 래핑하는 경우 문제가 발생할 수 있습니다.
- SWIG는 특정 언어의 특성에 완벽하게 맞지 않을 수 있습니다.
- SWIG는 모든 C/C++ 코드를 래핑할 수 있는 것은 아닙니다.## gg: 소프트웨어 아키텍처 시뮬레이터

### Summary

gg는 문서화 및 프레젠테이션 목적으로 사용되는 경량 소프트웨어 아키텍처 시뮬레이터입니다. gg는 다양한 소프트웨어 아키텍처를 정의하고 다양한 사용 시나리오에 대한 단계별 프레젠테이션을 생성하는 데 도움이 됩니다.

### Description

gg는 아키텍처 시각화를 통해 소프트웨어 아키텍처를 명확하게 이해하고 전달할 수 있도록 돕습니다. 컴포넌트, 인터페이스, 데이터 흐름, 사용 시나리오 등을 시각적으로 표현하여 복잡한 아키텍처를 간결하게 설명할 수 있습니다.

### Discussion

1. gg는 개발자, 설계자, 이해관계자 간의 의사소통을 원활하게 하여 프로젝트 이해도를 높입니다.
2. gg는 다양한 시나리오를 시각화하여 아키텍처의 동작 방식을 명확히 보여줍니다.
3. gg는 사용자 인터페이스가 직관적이고 사용하기 쉬워 빠르게 아키텍처를 시각화하고 문서화할 수 있습니다.

### Features

- 경량 소프트웨어 아키텍처 시뮬레이터
- 시각적 아키텍처 표현
- 단계별 사용 시나리오 프레젠테이션 생성

### Usage

#### Installation

```bash
npm install
npm run dev
```

### Recommendation

gg는 소프트웨어 아키텍처를 문서화하고 프레젠테이션해야 하는 모든 개발자 및 이해관계자에게 유용한 도구입니다. 특히 아키텍처 디자인 및 리뷰 과정에서 효과적으로 활용될 수 있습니다.

### External Links

- [gg 공식 웹사이트](https://gg-charts.com)
- [gg GitHub 저장소](https://github.com/jodigiordano/gg)

### Caution

- gg는 아직 개발 중이며, 일부 기능이 완벽하게 구현되지 않았을 수 있습니다.
- gg는 웹 기반 도구이므로 인터넷 연결이 필요합니다.

## EchoVault: Go로 작성된 임베디드 Redis 대안

### 요약

EchoVault는 Go로 작성된 경량의 임베디드 키-값 저장소로, Redis와 유사한 기능을 제공합니다. 메모리 내에서 작동하며, 빠르고 간편하게 사용할 수 있습니다. 특히 웹 애플리케이션의 세션 관리, 캐싱 등에 적합합니다.

### 설명

EchoVault는 Redis와 같은 기능을 제공하지만 별도의 Redis 서버를 설치할 필요가 없습니다. Go 애플리케이션에 직접 임베디드하여 사용할 수 있으며, 이는 개발 및 배포를 간소화합니다. EchoVault는 작은 메모리 풋프린트와 빠른 성능으로 인해 리소스 제약이 있는 시스템에서도 사용하기 적합합니다.

### 논의

1. **Redis 대비 장점**: EchoVault는 Redis보다 설치 및 설정이 간편합니다. 별도의 서버가 필요하지 않아 개발 환경에서 빠르게 사용할 수 있습니다.
2. **성능**: EchoVault는 메모리 내에서 작동하기 때문에 Redis보다 빠른 성능을 제공합니다. 
3. **제한**: EchoVault는 Redis와 같은 풍부한 기능을 모두 제공하지 않습니다. 예를 들어, 복잡한 트랜잭션, 데이터 지속성 등은 지원하지 않습니다.

### 기능

- 키-값 저장소
- 기본적인 데이터 타입 지원 (문자열, 정수, 부동 소수점)
- TTL (Time-to-Live) 지원
- 다양한 데이터 구조 지원 (리스트, 세트, 해시)
- TLS/mTLS 지원
- 복제 클러스터 지원 (RAFT 알고리즘)
- 액세스 제어 레이어
- 분산형 Pub/Sub 기능
- 데이터 지속성 레이어 (스냅샷 및 AOF 파일)
- 키 제거 정책 (수동 및 능동적 제거)
- 커맨드 확장 기능

### 사용법

#### 설치

```bash
go get github.com/EchoVault/EchoVault
```

#### 키-값 저장 및 가져오기

```go
package main

import (
  "fmt"
  "github.com/EchoVault/EchoVault"
)

func main() {
  // EchoVault 인스턴스 생성
  vault := echovault.New()

  // 키-값 저장
  vault.Set("name", "John Doe")

  // 값 가져오기
  name, err := vault.Get("name")
  if err != nil {
    fmt.Println("Error getting value:", err)
  } else {
    fmt.Println("Name:", name)
  }
}
```

#### TTL 설정

```go
// 10초 후 만료되도록 키-값 저장
vault.SetWithTTL("name", "John Doe", 10)
```

### 추천

EchoVault는 웹 애플리케이션에서 세션 관리, 캐싱 등을 구현하는 데 유용합니다. 또한, 리소스 제약이 있는 시스템에서 Redis와 같은 기능을 제공하는 경량의 솔루션을 찾는 개발자에게 적합합니다.

### 외부 링크

- [EchoVault GitHub 레포지토리](https://github.com/EchoVault/EchoVault)
- [EchoVault 문서](https://pkg.go.dev/github.com/EchoVault/EchoVault)

### 주의

- EchoVault는 메모리 내에서 작동하기 때문에 데이터 지속성을 제공하지 않습니다. 프로그램 종료 시 모든 데이터가 손실됩니다.
- EchoVault는 Redis와 같은 모든 기능을 제공하지 않습니다. 특정 기능이 필요한 경우 Redis를 사용하는 것이 좋습니다.
## Go 1.23의 새로운 `unique` 패키지를 사용하여 할당 및 비교 성능 향상

### 요약

Go 1.23은 `unique` 패키지를 도입하여 값의 중복 할당을 줄이고 비교 성능을 향상시킵니다. 이 패키지는 값을 중복 없이 저장하고 고유한 핸들을 제공하여 값 비교 시 성능을 높입니다.

### 설명

이 글은 Go 1.23에 새롭게 추가된 `unique` 패키지와 이 패키지가 해결하는 문제점을 설명합니다. `unique` 패키지는 값을 중복 없이 저장하고 고유한 핸들을 제공하여 값 비교 시 성능을 높이는 인터닝(Interning)을 구현합니다.

### 논의

1. **Go에서의 인터닝:**
    - Go 컴파일러는 문자열 상수를 컴파일 시에 인터닝하여 중복을 제거합니다.
    - Go 1.23 이전에는 런타임 값에 대한 인터닝은 서드파티 패키지를 통해 가능했습니다.

2. **`unique` 패키지:**
    - `unique` 패키지의 `Handle` 타입은 비교 가능한 값에 대한 고유한 ID를 제공합니다.
    - `Handle`은 내부적으로 동시성을 보장하는 적응형 라디스 트리(Adaptive Radix Tree)를 사용하여 값을 저장하고 고유한 핸들을 제공합니다.
    - `Handle`은 값 비교 시 참조 비교를 사용하여 값 비교에 필요한 시간을 줄입니다.

3. **`unique` 패키지와 일반 맵:**
    - `unique` 패키지는 일반 맵과 달리 가비지 컬렉터와 효율적으로 상호 작용하여 메모리 관리를 개선합니다.

### 기능

- 값 중복을 방지하여 메모리 할당 감소
- `Handle` 타입을 사용한 값 비교 성능 향상
- 가비지 컬렉터와 효율적인 상호 작용

### 사용

#### 설치

Go 1.23을 설치하여 `unique` 패키지를 사용할 수 있습니다.

#### `unique` 패키지 사용

아래 예시는 `unique` 패키지를 사용하여 IPv6 주소 정보를 저장하고 비교하는 방법을 보여줍니다.

```go
package main

import (
	"unique"
)

type addrDetail struct {
	isV6   bool
	zoneV6 string
}

func main() {
	h1 := unique.Make(addrDetail{isV6: true, zoneV6: "2001:0db8:0001:0000:0000:0ab9:C0A8:0102"})

	// 중복 값은 할당되지 않고 기존 핸들이 반환됩니다.
	h2 := unique.Make(addrDetail{isV6: true, zoneV6: "2001:0db8:0001:0000:0000:0ab9:C0A8:0102"})

	if h1 == h2 {
		println("주소가 같습니다")
	}

	// Value()는 기본 값의 복사본을 반환합니다.
	println(h1.Value().zoneV6)
}
```

### 추천

- 값을 중복 없이 저장하고 비교 성능을 향상시키려는 경우 `unique` 패키지를 사용하는 것이 좋습니다.
- 특히 대량의 값을 처리하거나 값 비교가 자주 필요한 경우 효과적입니다.

### 외부 링크

- Go 1.23 릴리즈 노트: https://go.dev/doc/go1.23
- `unique` 패키지 문서: https://pkg.go.dev/unique@master#Handle

### 주의

- `Handle` 타입은 값 자체가 아니라 값의 고유 ID를 나타냅니다.
- `Handle`을 사용하여 기본 값을 직접 참조할 수는 없습니다.
- `unique` 패키지는 Go 1.23부터 제공됩니다.

## 조직 아키텍처: 서비스 설계에 미치는 영향과 고객 여정의 중요성

### 요약

이 글은 조직 설계가 서비스 신뢰성에 미치는 중요성을 강조하며, 저렴하고 고품질의 제품을 빠르게 구축하는 제품 조직을 설계하기 위한 핵심 통찰력으로서 고객 여정의 개념을 소개합니다. 

### 설명

조직 아키텍처는 소프트웨어 아키텍처와 유사하게, 개별 부품(팀)보다 더 큰 전체(조직)를 구성하는 데 중점을 둡니다. 팀 간 상호 작용과 의존성에 따라 나타나는 조직의 부상 특성을 강조하며, 사람 간 협업이 시스템 간 상호 작용을 형성한다는 점을 설명합니다.

### 논의

1. **조직 구조의 중요성**: 조직 구조, 보고 라인, 배달 일정, 영역성 등은 협업에 큰 영향을 미치며, 컨웨이 법칙의 메커니즘에 따른 시스템 신뢰성에 직접적인 영향을 미칩니다.
2. **고객 여정의 통찰력**: 고객 여정을 분석하여 조직을 설계하면, 팀 간의 효과적인 협업을 통해 신뢰성 있는 시스템 구축이 가능합니다.
3. **마이크로 최적화의 한계**: TDD, CI/CD, SRE, 리팩토링, 기술 부채 해결, 3자 도구 구매 등은 마이크로 최적화로서 한계가 존재하며, 시스템 신뢰성을 크게 향상시키기 위해서는 더 큰 힘을 고려해야 합니다.

### 기능

- **팀 의존성 관리**: 팀 간 의존성 증가에 따른 오해 위험을 줄이고 효과적인 소통 및 협업을 통해 신뢰성 있는 시스템을 구축할 수 있도록 합니다.
- **고객 여정 분석**: 고객 여정을 분석하여 조직 구조를 설계함으로써 시스템의 신뢰성과 효율성을 높이고 고객 만족도를 향상시킬 수 있습니다.

### 사용

#### 설치

특별한 설치 과정은 없습니다. 조직 아키텍처는 팀 내부의 구조 및 프로세스를 재정비하는 전략적인 접근 방식입니다.

#### 조직 구조 재설계

- **기능별 분할**: 개발, 디자인, 마케팅, 운영 등 기능별로 팀을 분할하여 전문성을 강화하고 효율성을 높일 수 있습니다.
- **자율적인 팀 구성**: 각 팀에게 자율성을 부여하여 독립적인 의사 결정 및 실행을 가능하게 하여 책임감과 동기 부여를 높일 수 있습니다.
- **팀 간 협업 방식**: 정기적인 팀 간 미팅, 공동 프로젝트, 정보 공유 시스템 등을 통해 협업을 효과적으로 관리할 수 있습니다.

#### 제품 개발 프로세스 최적화

- **코드 리뷰**: 코드 품질 향상 및 개발 오류 예방
- **테스트 자동화**: 개발 단계에서부터 자동화된 테스트를 수행하여 안정적인 제품 개발
- **배포 자동화**: CI/CD 도구를 활용하여 배포 프로세스를 자동화하여 효율성 향상

### 권장 사항

- 팀 규모 및 제품 특성에 맞는 조직 아키텍처를 설계해야 합니다.
- 팀 구성원과의 소통을 통해 피드백을 수렴하고 조직 아키텍처를 지속적으로 개선해야 합니다.
- 팀 문화 및 가치를 정립하고 공유하여 긍정적인 협업 환경을 조성해야 합니다.

### 외부 링크

- [조직 구조 디자인](https://www.atlassian.com/team-playbook/organizing-teams/organizing-team-structure)
- [애자일 개발 방법론](https://www.atlassian.com/agile)

### 주의 사항

- 조직 아키텍처는 팀의 상황과 요구 사항에 따라 유연하게 변화해야 합니다.
- 팀 구성원의 의견을 충분히 수렴하고 합의를 도출해야 합니다.
- 갑작스러운 변화는 혼란을 야기할 수 있으므로 단계적으로 변화를 적용해야 합니다. 
## 마이크로서비스 아키텍처의 어려움: 분산 모놀리식의 함정

### 요약

이 글은 마이크로서비스 아키텍처를 구축할 때 발생할 수 있는 어려움 중 하나인 "분산 모놀리식"의 함정에 대해 다룹니다. 마이크로서비스는 각 서비스가 독립적으로 개발 및 배포될 수 있도록 설계되어 유연성과 확장성을 제공하지만, 서비스 간의 의존성이 복잡해지면서 모놀리식 시스템과 유사한 문제를 야기할 수 있습니다. 글에서는 이러한 문제를 피하기 위한 몇 가지 팁을 제공합니다.

### 설명

마이크로서비스 아키텍처는 애플리케이션을 작은 독립적인 서비스로 분할하여 개발 및 배포를 용이하게 하는 방식입니다. 각 서비스는 자체 데이터베이스와 API를 가지고 있으며, 다른 서비스와는 느슨하게 결합되어 있습니다. 이러한 구조는 개발 속도를 높이고, 확장성을 향상시키며, 개별 서비스의 독립적인 배포를 가능하게 합니다.

하지만 마이크로서비스 아키텍처는 분산 시스템의 복잡성을 수반합니다. 서비스 간의 통신, 데이터 일관성 유지, 오류 처리 등을 고려해야 하며, 잘못 설계된 경우 복잡성이 증가하여 개발 및 유지보수가 어려워질 수 있습니다. 특히, 서비스 간의 의존성이 복잡해지면서 하나의 서비스 변경이 다른 서비스에 영향을 미치는 "분산 모놀리식" 문제가 발생할 수 있습니다.

### 논의

1. **분산 모놀리식의 문제점:** 여러 서비스가 긴밀하게 연결되어 하나의 큰 시스템처럼 작동하면서 유연성과 확장성이 저하될 수 있습니다.
2. **마이크로서비스 간의 의존성 관리:** 서비스 간의 의존성을 최소화하고, 명확한 인터페이스를 통해 통신하는 것이 중요합니다.
3. **분산 시스템의 복잡성:** 분산 환경에서의 데이터 일관성, 오류 처리, 보안 등을 고려해야 합니다.

### 기능

- 마이크로서비스 아키텍처의 장점과 단점 설명
- 분산 모놀리식의 문제점 및 예시 제시
- 분산 모놀리식을 방지하기 위한 팁 제공

### 사용법

#### 설치

해당 글은 특정 설치 과정을 요구하지 않습니다.

#### 마이크로서비스 아키텍처 설계

- 서비스 간의 의존성을 최소화하고, 명확한 인터페이스를 정의합니다.
- 각 서비스는 독립적으로 개발 및 배포될 수 있도록 설계합니다.
- 서비스 간의 통신을 위한 명확한 프로토콜을 정의합니다.

#### 분산 모놀리식 방지

- 서비스 간의 의존성을 주의 깊게 관리합니다.
- 서비스를 독립적으로 배포하고 테스트할 수 있는 환경을 구축합니다.
- 서비스 간의 통신을 위한 효과적인 오류 처리 메커니즘을 구현합니다.

### 권장 사항

- 마이크로서비스 아키텍처를 적용하기 전에 신중하게 고려해야 합니다.
- 복잡한 시스템을 마이크로서비스로 분할할 때는 서비스의 경계를 명확하게 정의해야 합니다.
- 서비스 간의 통신을 위한 효과적인 메커니즘을 구축해야 합니다.

### 외부 링크

- [마이크로서비스 아키텍처](https://en.wikipedia.org/wiki/Microservices_architecture)
- [분산 모놀리식](https://martinfowler.com/articles/microservices.html)

### 주의 사항

- 마이크로서비스 아키텍처는 모든 경우에 적합하지 않습니다.
- 분산 시스템의 복잡성을 이해하고, 이를 관리할 수 있는 기술과 경험이 필요합니다.
## 안전한 Go 시스템 구축: 키 관리, 미들웨어 및 에러 처리 (10화)

### 요약

이 글은 Go 패키지 내에서 인증 및 권한 부여 메커니즘을 통합하는 방법에 대한 10번째 에피소드로, 소프트웨어 시스템의 보안 및 유지 관리를 위한 필수 전략을 개발자에게 제공합니다. 키 저장소를 사용하여 암호화 키를 구성하고 관리하는 방법과 Go 애플리케이션에 통합하는 방법을 배우고, 토큰 파싱, 사용자 ID 추출 및 역할 기반 액세스 제어를 위한 미들웨어 함수를 만드는 방법을 알아봅니다.

### 설명

본 에피소드는 다음과 같은 주제를 다룹니다.

* **키 저장소 구성 및 활용**: 키 저장소를 사용하여 디스크에서 암호화 키를 관리하는 방법을 설명하며, 활성 키 식별자 지정, 토큰 발행자 정의 및 애플리케이션 구성에 키 저장소 통합 방법을 자세히 설명합니다. 또한, Docker 환경에 키 저장소를 통합하여 안전한 애플리케이션 유지 관리를 위한 키 보안을 강조합니다.

* **인증 및 권한 부여 미들웨어 구축**: 토큰 파싱 및 사용자 ID 추출을 처리하는 미들웨어 함수를 구현하여 요청 처리 파이프라인에 인증 및 권한 부여 확인을 통합하는 방법을 보여줍니다. 클로저를 통해 인증 구성을 전달하여 요청 컨텍스트 내에서 클레임을 관리하고, 핸들러가 보안을 침해하지 않고 필요한 인증 정보에 액세스하도록 하는 방법을 설명합니다. 또한, 인증 및 권한 부여가 필요한 라우팅 설정 방법과 사용자 역할 및 권한에 따라 액세스 제어를 적용하는 미들웨어 함수 활용 방법에 대한 실용적인 예제를 제공합니다.

* **Go 애플리케이션에서의 에러 처리 및 컨텍스트 관리**: 다양한 유형의 에러 (인증 에러 포함)를 정의하고 관리하는 방법, 미들웨어 내에서 에러 처리를 중앙 집중화하여 디버깅을 간소화하고 코드 유지 관리를 향상시키는 방법, 컨텍스트를 사용하여 미들웨어와 핸들러 간에 중요한 정보 (사용자 클레임 포함)를 전달하여 깔끔하고 효율적인 데이터 흐름을 구현하는 방법을 설명합니다.

### 토론

1. 키 저장소를 사용한 암호화 키 관리 및 Go 애플리케이션에 통합하는 방법
2. 인증 및 권한 부여 미들웨어를 구현하는 다양한 방법
3. Go 애플리케이션에서 에러 처리 및 컨텍스트 관리를 위한 최적화 전략

### 기능

- 키 저장소 구성 및 사용 방법
- 인증 및 권한 부여 미들웨어 함수 구현
- 에러 처리 및 컨텍스트 관리 기법

### 사용

#### 설치

Go 언어 개발 환경을 설치해야 합니다.

#### 키 저장소 구성

본 에피소드에서 제공된 코드 예제를 참고하여 키 저장소를 구성할 수 있습니다.

#### 미들웨어 함수 구현

본 에피소드에서 설명된 미들웨어 함수 구현 방법을 활용하여 코드를 작성합니다.

#### 에러 처리 및 컨텍스트 관리

본 에피소드에서 제시된 에러 처리 및 컨텍스트 관리 기법을 적용합니다.

### 권장 사항

- 키 저장소를 안전하게 구축하고 관리하여 시스템 보안을 강화합니다.
- 미들웨어를 사용하여 인증 및 권한 부여 확인을 통합하여 코드를 깔끔하게 유지합니다.
- 에러 처리를 중앙 집중화하고 컨텍스트를 사용하여 데이터 흐름을 최적화합니다.

### 외부 링크

- [Ardan Labs 블로그](https://www.ardanlabs.com/blog/)
- [Go 언어 공식 문서](https://go.dev/doc/)

### 주의 사항

- 키 저장소의 보안 취약점은 시스템 전체의 보안에 위험이 될 수 있으므로 주의 깊게 설계하고 구현해야 합니다.
- 에러 처리 코드는 명확하고 가독성 있게 작성되어야 하며 예외 상황에 대한 적절한 대응 방안을 마련해야 합니다.
## Media over QUIC: QUIC 기반 새로운 실시간 미디어 프로토콜

### Summary

Media over QUIC은 IETF에서 개발 중인 새로운 실시간 미디어 프로토콜입니다. HTTP/3을 위해 설계된 QUIC(빠른 TCP/UDP 대체)를 기반으로 합니다.

### Description

Media over QUIC은 QUIC을 사용하여 웹 브라우저에서 실시간 미디어 스트리밍을 가능하게 하는 새로운 프로토콜입니다. WebTransport와 WebCodecs를 통해 웹 지원을 제공하며, CDN은 MoqTransport를 통해 지원합니다. 또한 ffmpeg 및 OBS 플러그인을 통해 네이티브 지원을 제공합니다. 

### Features

- WebTransport 및 WebCodecs를 통한 웹 지원
- MoqTransport를 통한 CDN 지원
- ffmpeg 및 OBS 플러그인을 통한 네이티브 지원 (개발 중)

### Usage

Media over QUIC은 아직 개발 초기 단계에 있으며, 많은 기능이 부족합니다. 웹 브라우저 또는 네이티브 애플리케이션에서 실시간 미디어 스트리밍을 위한 실험적인 프로토콜로 사용할 수 있습니다.

### Recommendation

Media over QUIC은 실시간 미디어 스트리밍을 위한 새로운 프로토콜로, 낮은 지연 시간과 높은 성능을 제공할 수 있는 잠재력이 있습니다. 아직 개발 초기 단계이지만, 웹 브라우저 또는 네이티브 애플리케이션에서 실시간 미디어 스트리밍을 위한 새로운 가능성을 제시합니다.

### External Links

- Media over QUIC 공식 웹사이트: [https://quic.video/](https://quic.video/)
- Media over QUIC GitHub 저장소: [https://github.com/kixelated/moq-rs](https://github.com/kixelated/moq-rs)
- IETF MoQ 작업 그룹: [https://datatracker.ietf.org/group/moq/about/](https://datatracker.ietf.org/group/moq/about/)

### Caution

- Media over QUIC은 아직 개발 초기 단계에 있으며, 많은 기능이 부족합니다.
- 모든 웹 브라우저 및 네트워크에서 지원되지 않을 수 있습니다.
- 이 프로토콜은 변경될 수 있으며, 특히 개발에 참여하는 경우 더욱 그렇습니다. 
## 계층형 스토리지는 카프카 문제를 해결하지 못합니다

### 요약

이 글은 계층형 스토리지가 카프카의 문제를 해결하지 못하는 이유를 설명합니다. 계층형 스토리지는 데이터를 여러 계층으로 나누어 저장하여 성능과 비용 간의 균형을 맞추는 방법입니다. 그러나 카프카는 메시지 처리 시스템으로서 데이터를 빠르고 안정적으로 처리하는 것이 중요합니다. 계층형 스토리지는 이러한 요구 사항을 충족시키지 못하며, 카프카의 성능 저하를 초래할 수 있습니다.

### 설명

계층형 스토리지는 데이터를 여러 계층으로 나누어 저장하여 성능과 비용 간의 균형을 맞추는 방법입니다. 가장 빠르고 비용이 많이 드는 계층에는 빈번하게 액세스되는 데이터를 저장하고, 느리고 비용이 저렴한 계층에는 덜 빈번하게 액세스되는 데이터를 저장합니다. 이러한 방식으로 계층형 스토리지는 전체 시스템 성능을 유지하면서 비용을 절감할 수 있습니다.

그러나 계층형 스토리지는 카프카와 같은 메시지 처리 시스템에 적합하지 않습니다. 카프카는 데이터를 빠르고 안정적으로 처리하는 것이 중요합니다. 계층형 스토리지는 데이터를 여러 계층으로 이동시키는 데 시간이 걸리기 때문에 카프카의 성능을 저하시킬 수 있습니다. 또한 계층형 스토리지는 데이터의 일관성을 유지하는 데 어려움을 겪을 수 있습니다.

### 토론

1. **계층형 스토리지는 카프카의 성능을 저하시킬 수 있습니다.** 계층형 스토리지는 데이터를 여러 계층으로 이동시키는 데 시간이 걸리기 때문에 카프카의 성능을 저하시킬 수 있습니다. 특히 카프카는 메시지를 실시간으로 처리해야 하기 때문에 데이터 이동 시간은 매우 중요합니다.
2. **계층형 스토리지는 데이터의 일관성을 유지하는 데 어려움을 겪을 수 있습니다.** 계층형 스토리지는 데이터를 여러 계층으로 분산시키기 때문에 데이터의 일관성을 유지하는 데 어려움을 겪을 수 있습니다. 특히 데이터가 여러 계층으로 이동될 때 데이터의 일관성을 유지하는 것은 매우 어려운 문제입니다.
3. **카프카는 고성능 메시지 처리 시스템이기 때문에 계층형 스토리지보다 다른 솔루션이 더 적합합니다.** 카프카는 고성능 메시지 처리 시스템이기 때문에 계층형 스토리지보다 다른 솔루션이 더 적합합니다. 예를 들어 카프카는 분산된 데이터베이스 또는 캐시를 사용하여 고성능과 일관성을 유지할 수 있습니다.

### 기능

- 계층형 스토리지는 데이터를 여러 계층으로 나누어 저장합니다.
- 계층형 스토리지는 성능과 비용 간의 균형을 맞춥니다.

### 사용법

#### 설치

계층형 스토리지는 다양한 방식으로 구현할 수 있습니다. 예를 들어 OpenStack Swift와 같은 오픈소스 소프트웨어를 사용하거나 AWS S3와 같은 클라우드 스토리지 서비스를 사용할 수 있습니다.

#### 계층형 스토리지 사용

계층형 스토리지는 데이터를 여러 계층으로 나누어 저장하기 때문에 데이터를 여러 계층으로 이동시키는 방법을 정의해야 합니다. 또한 데이터의 일관성을 유지하기 위한 메커니즘을 구현해야 합니다.

### 권장 사항

계층형 스토리지는 카프카와 같은 메시지 처리 시스템에 적합하지 않습니다. 카프카는 고성능 메시지 처리 시스템이기 때문에 계층형 스토리지보다 다른 솔루션이 더 적합합니다.

### 외부 링크

- [계층형 스토리지](https://en.wikipedia.org/wiki/Hierarchical_storage_management)
- [카프카](https://kafka.apache.org/)

### 주의 사항

- 계층형 스토리지는 카프카의 성능을 저하시킬 수 있습니다.
- 계층형 스토리지는 데이터의 일관성을 유지하는 데 어려움을 겪을 수 있습니다.
## Chiko: 터미널에서 사용하는 아름다운 gRPC 클라이언트

### Summary

Chiko는 터미널 사용자 인터페이스(TUI) 기반의 gRPC 클라이언트로, 터미널에서 아름다운 인터페이스를 통해 gRPC 서비스와 상호 작용할 수 있도록 돕는 간단한 도구입니다. Chiko는 gRPC 서비스와의 상호 작용에 `grpcurl` 라이브러리를 사용하고, 아름다운 터미널 인터페이스는 `rivo`의 `tview` 라이브러리를 사용하여 구현되었습니다. 

### Description

개발자는 종종 gRPC 서비스와의 상호 작용을 위해 `grpcurl`을 사용합니다. 하지만 `grpcurl`의 다양한 옵션과 문법을 일일이 기억하는 것은 쉽지 않습니다. Chiko는 이러한 어려움을 해소하기 위해 터미널에서 gRPC 서비스와의 상호 작용을 쉽고 편리하게 만들어주는 도구입니다. 

### Features

- 터미널 반사를 이용하여 gRPC 메서드를 나열합니다.
- 샘플 요청 페이로드를 생성합니다.
- 북마크 기능을 제공합니다.

### Usage

#### 설치

**Homebrew**

```bash
brew install felangga/chiko/chiko
```

**Go**

```bash
go install github.com/felangga/chiko@latest
```

**수동 설치**

```bash
git clone https://github.com/felangga/chiko
cd chiko
go run ./...
```

### Recommendation

gRPC 서비스와의 상호 작용을 터미널에서 쉽고 편리하게 하고 싶은 모든 개발자에게 Chiko를 추천합니다. 특히, gRPC 서비스와의 상호 작용에 `grpcurl`을 사용하면서 명령어 옵션과 문법을 기억하는 데 어려움을 겪는 개발자에게 유용합니다.

### External Links

- [Chiko GitHub 레포지토리](https://github.com/felangga/chiko)
- [Chiko 릴리즈 페이지](https://github.com/felangga/chiko/releases)

### Caution

- Chiko는 현재 개발 중이며, 일부 기능은 아직 완벽하게 구현되지 않았습니다.
- Chiko는 특정 범위의 gRPC 서비스와 호환되도록 설계되었습니다. 호환되지 않는 서비스의 경우 오류가 발생할 수 있습니다.
- Chiko를 사용하기 전에 사용 설명서를 꼼꼼히 읽어보는 것이 좋습니다.
## WATER: WebAssembly 기반 플러그형 전송 실행 환경

### Summary

WATER는 WebAssembly 기반의 플러그형 전송 실행 환경으로, 다양한 언어로 작성된 새로운 전송 프로토콜을 구축, 배포 및 실행하는 혁신적인 방법을 제공합니다. 이 시스템은 WebAssembly를 통해 전송 프로토콜을 안전하고 샌드박스 환경에서 실행하며, 다양한 플랫폼에서 호환됩니다.

### Description

WATER는 기존 플러그형 전송 디자인의 한계를 극복하고 더욱 유연한 방식으로 전송 프로토콜을 관리할 수 있도록 설계되었습니다. WebAssembly를 사용하여 전송 프로토콜을 컴파일하고 실행하기 때문에, 호스트 애플리케이션과 전송 프로토콜 간의 언어 제약을 해소하며, 새로운 프로토콜을 효율적으로 배포하고 업데이트할 수 있습니다.

### Discussion

1. **WebAssembly 활용**: WATER는 WebAssembly를 활용하여 전송 프로토콜을 안전하고 효율적으로 실행합니다. WebAssembly는 다양한 프로그래밍 언어에서 지원되며, 샌드박스 환경을 제공하여 보안성을 강화합니다.
2. **플러그형 전송의 장점**: 플러그형 전송 디자인은 새로운 전송 프로토콜을 쉽게 추가하고 업데이트할 수 있도록 하여 유연성을 높입니다.
3. **검열 우회**: WATER는 WebAssembly 기반의 플러그형 전송을 통해 검열 우회 도구를 더욱 강력하게 만들 수 있습니다. 다양한 전송 프로토콜을 지원하여 검열 우회 기능을 확장할 수 있으며, 새로운 프로토콜을 쉽게 추가할 수 있습니다.

### Features

- WebAssembly 기반의 플러그형 전송 지원
- 다양한 언어에서 전송 프로토콜을 작성 가능
- 안전하고 샌드박스 환경에서 전송 프로토콜 실행
- 새로운 프로토콜을 효율적으로 배포 및 업데이트 가능
- 클라이언트 및 서버 애플리케이션 모두 지원

### Usage

#### Installation

WATER 설치 방법은 공식 문서를 참조하세요.

#### 전송 프로토콜 실행

WATER는 WebAssembly Transport Module (WATM)을 사용하여 전송 프로토콜을 실행합니다. WATM은 WebAssembly로 컴파일된 전송 프로토콜 모듈입니다.

#### 전송 프로토콜 개발

WATER는 개발자가 자신만의 WATM을 개발할 수 있도록 다양한 API를 제공합니다.

### Recommendation

WATER는 검열 우회 도구, 분산형 애플리케이션, 보안 통신 등 다양한 분야에서 활용될 수 있습니다. 특히 새로운 전송 프로토콜을 구현하고 배포해야 하는 경우에 유용합니다.

### External Links

- [WATER 공식 웹사이트](https://water.refraction.network/)
- [WATER GitHub 저장소](https://github.com/refraction-networking/water)

### Caution

- WATER는 아직 개발 단계에 있으며, 안정성 및 성능이 완벽하게 검증되지 않았습니다.
- WebAssembly 환경에서 실행되는 전송 프로토콜은 보안 문제에 취약할 수 있습니다.
- WATER 사용 전에 관련 문서를 충분히 숙지해야 합니다. 
## utls: Go 언어용 TLS/SSL 유틸리티 라이브러리

### Summary

utls는 Go 언어에서 TLS/SSL 연결을 설정하고 관리하는 데 사용되는 다양한 유틸리티 함수와 구조체를 제공하는 라이브러리입니다. 이 라이브러리는 TLS 연결을 더욱 효율적이고 안전하게 관리할 수 있도록 도와줍니다. 특히, utls는 ClientHello를 조작하여 TLS 연결의 지문을 숨기는 기능을 제공하여 망 필터링 우회 등의 목적으로 유용하게 사용될 수 있습니다.

### Description

utls는 Go 표준 TLS 라이브러리의 포크이며, ClientHello 조작, 저수준 핸드셰이크 접근, 가짜 세션 티켓 생성 등 다양한 기능을 제공합니다. 기본적으로 utls는 Go 표준 TLS 라이브러리와 호환되며, 대부분의 경우 기존 TLS 코드를 utls로 쉽게 마이그레이션할 수 있습니다.

### Features

- **ClientHello 지문 숨기기:** utls는 ClientHello 메시지의 내용을 조작하여 TLS 연결의 지문을 숨기는 기능을 제공합니다. 이를 통해 망 필터링 우회 등의 목적으로 사용될 수 있습니다.
- **저수준 핸드셰이크 접근:** utls는 TLS 핸드셰이크의 저수준 접근을 제공하여 개발자가 핸드셰이크 프로세스를 더욱 자세하게 제어할 수 있도록 지원합니다.
- **가짜 세션 티켓:** utls는 서버에서 발급한 세션 티켓과 유사한 가짜 세션 티켓을 생성하는 기능을 제공합니다. 이를 통해 TLS 핸드셰이크의 특정 부분을 숨기고 RTT(Round Trip Time)를 줄일 수 있습니다.
- **다양한 ClientHello ID:** utls는 다양한 ClientHello ID를 제공하여 다양한 환경 및 목적에 맞게 ClientHello를 조작할 수 있도록 지원합니다.
- **사용자 지정 TLS 확장:** utls는 사용자 지정 TLS 확장을 추가하는 기능을 제공하여 고급 TLS 연결 설정을 지원합니다.

### Usage

#### Installation

```bash
go get github.com/refraction-networking/utls
```

#### ClientHello 지문 숨기기

```go
import (
	"crypto/tls"
	"fmt"
	"github.com/refraction-networking/utls"
	"net"
)

func main() {
	// TCP 연결 생성
	tcpConn, err := net.Dial("tcp", "example.com:443")
	if err != nil {
		fmt.Println("TCP 연결 오류:", err)
		return
	}

	// TLS 설정 옵션 구성
	tlsConfig := &tls.Config{
		ServerName: "example.com",
	}

	// utls.UClient를 사용하여 TLS 연결 생성 (HelloRandomized 사용)
	uTlsConn, err := utls.UClient(tcpConn, tlsConfig, utls.HelloRandomized)
	if err != nil {
		fmt.Println("TLS 연결 오류:", err)
		return
	}

	// TLS 연결 사용
	// ...
}
```

#### 저수준 핸드셰이크 접근

```go
import (
	"crypto/tls"
	"fmt"
	"github.com/refraction-networking/utls"
	"net"
)

func main() {
	// TCP 연결 생성
	tcpConn, err := net.Dial("tcp", "example.com:443")
	if err != nil {
		fmt.Println("TCP 연결 오류:", err)
		return
	}

	// TLS 설정 옵션 구성
	tlsConfig := &tls.Config{
		ServerName: "example.com",
	}

	// utls.UClient를 사용하여 TLS 연결 생성 (HelloCustom 사용)
	uTlsConn, err := utls.UClient(tcpConn, tlsConfig, utls.HelloCustom)
	if err != nil {
		fmt.Println("TLS 연결 오류:", err)
		return
	}

	// ClientHello 메시지에 접근
	fmt.Println("ClientHello:", uTlsConn.Hello)

	// 핸드셰이크 진행 중에 핸드셰이크 상태 정보에 접근
	fmt.Println("Handshake State:", uTlsConn.HandshakeState)

	// TLS 연결 사용
	// ...
}
```

#### 가짜 세션 티켓 생성

```go
import (
	"crypto/tls"
	"fmt"
	"github.com/refraction-networking/utls"
	"net"
)

func main() {
	// 가짜 세션 티켓 생성
	sessionTicket := []byte("fake_session_ticket")
	sessionState := utls.MakeClientSessionState(sessionTicket, uint16(tls.VersionTLS12), tls.TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256, nil, nil, nil)

	// TCP 연결 생성
	tcpConn, err := net.Dial("tcp", "example.com:443")
	if err != nil {
		fmt.Println("TCP 연결 오류:", err)
		return
	}

	// TLS 설정 옵션 구성
	tlsConfig := &tls.Config{
		ServerName: "example.com",
	}

	// utls.UClient를 사용하여 TLS 연결 생성 (HelloCustom 사용)
	uTlsConn, err := utls.UClient(tcpConn, tlsConfig, utls.HelloCustom)
	if err != nil {
		fmt.Println("TLS 연결 오류:", err)
		return
	}

	// 가짜 세션 티켓 설정
	uTlsConn.SetSessionState(sessionState)

	// TLS 연결 사용
	// ...
}
```

### Recommendation

utls는 Go 언어에서 TLS/SSL 연결을 조작하고 관리하는 데 유용한 라이브러리입니다. 망 필터링 우회, TLS 연결 분석, 핸드셰이크 프로세스 제어 등 다양한 목적으로 utls를 사용할 수 있습니다.

### External Links

- [utls GitHub Repository](https://github.com/refraction-networking/utls)
- [utls 문서](https://pkg.go.dev/github.com/refraction-networking/utls)

### Caution

- utls는 Go 언어의 특정 버전과 호환될 수 있습니다. 사용하기 전에 호환성을 확인하십시오.
- utls를 사용하여 TLS 연결을 조작할 때는 보안 취약점을 발생시키지 않도록 주의하십시오.
- utls는 TLS 연결을 분석하고 조작하는 데 사용될 수 있으므로, 해당 기능을 악용하여 타인에게 피해를 입히는 행위는 금지되어 있습니다.


## 메모리 보호 라이브러리: Memguard

### Summary

Memguard는 C/C++ 프로그램에서 메모리 공격으로부터 민감한 데이터를 보호하는 오픈 소스 라이브러리입니다. 메모리 격리, 암호화, 무결성 검증 기능을 제공하여 데이터 유출 및 변조 위험을 줄입니다.

### Description

Memguard는 데이터 보호를 위해 다음과 같은 기술을 사용합니다.

- **메모리 격리:** 민감한 데이터를 별도의 보호된 메모리 영역에 저장하여 다른 코드가 접근하지 못하도록 합니다.
- **암호화:** 데이터를 저장하거나 전송하기 전에 암호화하여 데이터가 노출되어도 해독할 수 없도록 합니다.
- **무결성 검증:** 데이터가 변경되지 않았는지 확인하여 무결성을 보장합니다.

### Features

- 메모리 격리 기능 제공
- 데이터 암호화 기능 제공
- 데이터 무결성 검증 기능 제공
- 다양한 플랫폼 지원
- 오픈 소스 라이브러리

### Usage

#### Installation

```bash
git clone https://github.com/awnumar/memguard.git
cd memguard
cmake .
make
```

#### 기본 사용법

```c++
#include <memguard/memguard.h>

int main() {
  // 보호된 메모리 영역 할당
  void* mem = memguard_alloc(1024);

  // 데이터 저장
  memcpy(mem, "secret data", 12);

  // 데이터 접근
  char* data = (char*)mem;
  printf("Data: %s\n", data);

  // 메모리 해제
  memguard_free(mem);

  return 0;
}
```

### Recommendation

Memguard는 민감한 데이터를 보호해야 하는 C/C++ 프로그램에 사용할 수 있는 유용한 라이브러리입니다. 특히, 금융, 의료, 보안 등 데이터 유출 위험이 높은 분야에서 유용하게 활용될 수 있습니다.

### External Links

- [Memguard GitHub Repository](https://github.com/awnumar/memguard)
- [Memguard Documentation](https://memguard.readthedocs.io/en/latest/)

### Caution

- Memguard는 메모리 보호 기능을 제공하지만, 보안은 절대적인 것이 아닙니다. 
- 다른 보안 조치와 함께 사용해야 보다 안전하게 데이터를 보호할 수 있습니다.
- 라이브러리 사용 전에 문서를 꼼꼼히 읽어 사용법과 제약 사항을 파악해야 합니다. 
## Golang JWT TPM 보안 구현

### 요약

이 레포지토리는 Go 언어를 사용하여 TPM(Trusted Platform Module)을 이용한 JWT(JSON Web Token) 보안 구현 방법을 보여줍니다. TPM은 컴퓨터 하드웨어에 내장된 칩으로, 암호화 키를 안전하게 저장하고 관리할 수 있도록 합니다. JWT는 웹 애플리케이션에서 사용자 인증 및 권한 관리를 위한 표준 토큰 포맷입니다. 이 레포지토리는 TPM과 JWT를 결합하여 강력한 보안 구현을 제공합니다.

### 설명

이 레포지토리는 Go 언어로 작성된 예제 프로젝트로, TPM을 사용하여 JWT를 보호하는 방법을 보여줍니다. TPM은 키를 암호화하고 보관하는 데 사용되며, JWT는 사용자 인증과 권한 관리에 사용됩니다. 이 레포지토리는 TPM과 JWT를 함께 사용하여 보안을 강화하는 방법을 보여줍니다.

### 논의

1. **TPM을 이용한 보안 강화:** TPM은 하드웨어 기반 보안을 제공하여 키를 더 안전하게 보호할 수 있습니다. 이는 소프트웨어 기반 암호화 방식보다 공격에 대한 저항력이 높습니다.
2. **JWT 표준 활용:** JWT는 웹 애플리케이션에서 사용자 인증과 권한 관리를 위한 표준 토큰 포맷으로, 다양한 플랫폼에서 널리 사용됩니다. 이로 인해 다른 시스템과의 호환성을 보장하고 개발 효율성을 높일 수 있습니다.
3. **TPM과 JWT의 시너지 효과:** TPM과 JWT를 함께 사용하면 보안을 강화하고 사용자 인증 및 권한 관리를 효율적으로 수행할 수 있습니다. 이는 특히 민감한 정보를 다루는 웹 애플리케이션에 적합합니다.

### 기능

- TPM을 사용한 JWT 암호화 및 복호화
- JWT 토큰 생성 및 검증
- TPM과 JWT를 결합한 안전한 보안 구현
- 다양한 키 유형 지원 (RS256, PS256, ES256)
- 암호화된 세션 지원
- 외부 키 가져오기 지원
- 암호 및 PCR 정책 지원

### 사용

#### 설치

1. Go 언어를 설치합니다.
2. `go get github.com/salrashid123/golang-jwt-tpm` 명령어를 실행하여 프로젝트를 다운로드합니다.
3. TPM 드라이버를 설치합니다. TPM 드라이버는 TPM 칩 제조업체의 웹사이트에서 다운로드할 수 있습니다.

#### 예제 사용

1. `example` 폴더에서 제공되는 예제 코드를 실행하여 TPM과 JWT를 사용하는 방법을 확인합니다.
2. `nopolicy`, `policy_password`, `policy_pcr` 폴더의 예제는 각각 암호화된 세션, 암호 정책, PCR 정책 적용 방법을 보여줍니다.

### 추천

이 레포지토리는 TPM과 JWT를 함께 사용하여 안전한 보안 구현을 원하는 개발자들에게 유용합니다. 특히 웹 애플리케이션에서 사용자 인증 및 권한 관리를 강화하고자 하는 개발자에게 추천합니다.

### 외부 링크

- [TPM](https://en.wikipedia.org/wiki/Trusted_Platform_Module)
- [JWT](https://jwt.io/)
- [go-jwt](https://github.com/golang-jwt/jwt)
- [go-tpm](https://github.com/google/go-tpm)
- [tpm2_tools](https://github.com/tpm2-software/tpm2-tools)

### 주의

- TPM은 모든 컴퓨터에 장착되어 있지 않을 수 있습니다. 컴퓨터에 TPM 칩이 있는지 확인하십시오.
- TPM 드라이버 설치 과정에서 오류가 발생할 수 있습니다. TPM 드라이버 제조업체 웹사이트에서 자세한 설치 정보를 확인하십시오.
- TPM과 JWT를 사용하는 것은 복잡한 작업일 수 있습니다. 이 레포지토리의 코드를 참고하여 자신의 프로젝트에 맞게 수정하십시오.
- 이 레포지토리는 Google에서 공식적으로 지원하지 않습니다.
## 문자열에 비밀 정보를 저장하지 마세요: 노출 위험

### 요약

이 글은 소프트웨어 개발에서 비밀 정보를 저장하는 방식으로 문자열을 사용하는 것은 매우 위험한 행위라는 것을 강조합니다. 문자열은 코드 내에서 쉽게 노출될 수 있으며, 이는 해커가 비밀 정보를 훔쳐 악용하는 데 사용될 수 있습니다.

### 설명

이 글은 API 키, 암호, 토큰, 결제 카드 정보와 같이 민감한 정보를 문자열로 저장하지 말아야 한다는 중요성을 강조합니다. 이는 문자열이 코드 내에서 쉽게 노출될 수 있으며, 버전 관리 시스템, 로그 파일 또는 소스 코드 자체에서도 노출될 수 있기 때문입니다.

### 토론

1. **문자열은 코드 내에서 쉽게 노출될 수 있습니다.** 코드 검토, 로그 파일 또는 버전 관리 시스템을 통해 쉽게 노출될 수 있습니다.
2. **문자열은 암호화가 어렵습니다.** 문자열은 암호화되더라도 코드 내에서 해독 키를 찾는 것이 쉽기 때문에 보안상 취약합니다.
3. **문자열은 보안 취약성을 악용하기 쉽습니다.** 해커는 소스 코드를 분석하여 문자열에 저장된 비밀 정보를 훔칠 수 있습니다.

### 기능

- 비밀 정보를 안전하게 저장하는 방법에 대한 이해를 높입니다.
- 문자열을 사용하지 않고 비밀 정보를 저장하는 방법을 소개합니다.
- 소프트웨어 보안을 강화하는 방법을 제시합니다.

### 사용

#### 비밀 정보를 안전하게 저장하는 방법

- **환경 변수를 사용하세요.** 환경 변수는 코드 내에서 숨겨진 정보를 저장할 수 있습니다.
- **암호화된 저장소를 사용하세요.** 암호화된 저장소는 비밀 정보를 안전하게 저장하고 암호화된 키를 안전하게 관리할 수 있습니다.
- **비밀 정보 관리 서비스를 사용하세요.** 비밀 정보 관리 서비스는 비밀 정보를 안전하게 저장하고 관리하는 데 도움이 됩니다.

### 권장 사항

- 소프트웨어 개발 시 비밀 정보를 저장하는 데 문자열을 사용하지 마세요.
- 비밀 정보를 안전하게 저장하는 방법을 항상 고려하세요.
- 소프트웨어 보안에 대해 더 자세히 알아보세요.

### 주의 사항

- 비밀 정보를 저장할 때는 주의가 필요합니다.
- 비밀 정보를 저장하는 방법을 신중하게 선택하세요.
- 소프트웨어 보안은 매우 중요합니다.
## CGO 핸들 최적화: Go와 C 상호작용 개선하기

### Summary

CGO는 Go에서 C 코드를 호출할 수 있도록 하는 강력한 기능입니다. 하지만, CGO 핸들은 메모리 관리 문제를 야기할 수 있으며 성능 저하로 이어질 수 있습니다. 이 글에서는 CGO 핸들을 최적화하여 Go와 C 상호 작용 시 효율성을 높이는 방법을 다룹니다. 특히, 고성능 PHP SAPI인 FrankenPHP의 예시를 통해 CGO 핸들 최적화의 필요성과 구현 방법을 설명합니다.

### Description

Go는 강력한 성능과 편의성을 제공하는 프로그래밍 언어이지만, 기존 C 라이브러리를 활용해야 할 때 CGO를 사용하여 두 언어 간 상호 작용을 구현해야 합니다. CGO는 Go 코드에서 C 함수를 호출하고, C 데이터 구조를 Go로 전달하는 방식으로 동작합니다. 

CGO 핸들은 Go의 가비지 수집 시스템과 C의 수동 메모리 관리 방식 사이의 차이로 인해 메모리 누수나 세그먼트 오류를 야기할 수 있습니다. 또한, CGO 핸들은 Go의 고성능 특성을 저해할 수 있습니다.

### Discussion

1. **CGO 핸들의 메모리 관리**: CGO 핸들은 Go와 C 사이에서 데이터를 전달하는 역할을 합니다. 이 핸들은 C 메모리를 가리키므로, Go의 가비지 수집 시스템이 C 메모리에 접근할 수 없다는 문제가 발생할 수 있습니다.
2. **CGO 핸들의 성능**: CGO는 Go 코드와 C 코드 간의 호출 오버헤드를 발생시켜 성능 저하를 유발할 수 있습니다. 또한, CGO 핸들은 Go의 가비지 수집 시스템을 방해하여 메모리 할당 및 해제 속도를 늦출 수 있습니다.
3. **CGO 핸들의 안정성**: CGO 핸들은 메모리 관리 문제로 인해 코드의 안정성을 떨어뜨릴 수 있습니다. 예를 들어, CGO 핸들을 통해 해제된 메모리에 접근하려고 하면 세그먼트 오류가 발생할 수 있습니다.

### Features

- **CGO 핸들 사용**: CGO를 통해 Go에서 C 코드를 호출하고, C 데이터 구조를 Go로 전달할 수 있습니다.
- **메모리 안전성**: CGO 핸들은 메모리 안전성 문제를 일으킬 수 있지만, 적절한 메모리 관리 기법을 적용하여 이 문제를 해결할 수 있습니다.
- **성능 최적화**: CGO 핸들의 성능을 최적화하여 Go의 고성능 특성을 유지할 수 있습니다.

### Usage

#### Installation

```bash
go mod edit -module=example.com/myproject
go get github.com/golang/example/stringutil
```

#### CGO 핸들 사용

```go
package main

import "C"

func main() {
  // C 함수 호출
  C.some_c_function()

  // C 데이터 구조 사용
  var c_data C.struct_data
  // ...
}
```

#### 메모리 관리

```go
package main

import "C"

type CData struct {
  c *C.struct_data
}

func NewCData(data *C.struct_data) *CData {
  return &CData{c: data}
}

func (cd *CData) Free() {
  C.free(unsafe.Pointer(cd.c))
}

func main() {
  // CData 생성
  cd := NewCData(C.some_c_function())

  // ...

  // CData 해제
  cd.Free()
}
```

### Recommendation

CGO는 Go에서 C 코드를 활용하는 강력한 도구이지만, 메모리 관리 및 성능 측면에서 주의가 필요합니다. 메모리 누수를 방지하고 성능을 최적화하기 위해 CGO 핸들을 올바르게 사용하고 적절한 메모리 관리 기법을 적용해야 합니다.

### External Links

- [CGO Documentation](https://golang.org/cmd/cgo/)
- [CGO Memory Management](https://www.ardanlabs.com/blog/2018/08/cgo-memory-management.html)

### Caution

- CGO 핸들은 메모리 누수 및 세그먼트 오류를 야기할 수 있습니다.
- CGO는 Go의 성능을 저해할 수 있습니다.
- CGO 핸들 사용 시, C 코드와 Go 코드 간의 상호 작용에 대한 충분한 이해가 필요합니다. 
## SoftBlake3: 순수 Go로 구현된 BLAKE3 해싱 함수

### Summary

SoftBlake3는 BLAKE3 해싱 알고리즘을 순수 Go 언어로 구현한 라이브러리입니다. BLAKE3는 성능과 보안성이 뛰어난 해싱 알고리즘으로, 특히 속도 면에서 뛰어납니다. SoftBlake3는 BLAKE3의 장점을 그대로 가져와 Go 개발자들이 쉽게 사용할 수 있도록 설계되었습니다.

### Description

SoftBlake3는 BLAKE3 해싱 알고리즘을 C# 대신 순수 Go 언어로 구현하여, Go 환경에서 BLAKE3의 빠른 속도와 보안성을 활용할 수 있도록 합니다. 이 라이브러리는 다양한 애플리케이션에서 사용할 수 있도록 설계되었으며, 특히 다음과 같은 분야에서 유용합니다.

* 데이터 무결성 검증
* 파일 및 데이터베이스 해싱
* 암호화 해시 생성
* 블록체인 기술

### Discussion

1. **성능**: SoftBlake3는 BLAKE3 해싱 알고리즘을 최대한 활용하여 매우 빠른 해싱 속도를 제공합니다. 다른 Go 해싱 라이브러리에 비해 성능이 뛰어납니다.
2. **안전성**: BLAKE3는 보안성이 검증된 해싱 알고리즘으로, SoftBlake3는 이를 안전하게 구현했습니다.
3. **사용 편의성**: SoftBlake3는 Go 개발자들이 쉽게 사용할 수 있도록 설계되었습니다. 간단한 API를 통해 해싱 작업을 수행할 수 있습니다.

### Features

- BLAKE3 해싱 알고리즘의 순수 Go 구현
- 빠른 해싱 속도
- 뛰어난 보안성
- 사용하기 쉬운 API

### Usage

#### Installation

```
go get github.com/lemon-mint/softblake3
```

#### 해싱

```Go
package main

import (
	"encoding/hex"
	"fmt"

	"github.com/lemon-mint/softblake3"
)

func main() {
	// 새로운 해셔 생성
	h := softblake3.New()
	text := "Hello, World!"
	h.Write([]byte(text))

	// 바이트 슬라이스 형태로 해시 값 가져오기
	hash := h.Sum(nil)

	fmt.Println(hex.EncodeToString(hash))
}
```

### Recommendation

SoftBlake3는 속도와 보안성이 중요한 애플리케이션에서 BLAKE3 해싱 알고리즘을 사용하고자 하는 Go 개발자들에게 추천합니다.

### External Links

- [SoftBlake3 GitHub Repository](https://github.com/lemon-mint/softblake3)
- [BLAKE3 공식 웹사이트](https://blake3.net/) 
## Go 1.23 릴리즈 노트

### Summary

Go 1.23은 Go 프로그래밍 언어의 새로운 릴리즈이며, 다양한 기능 개선과 성능 향상을 제공합니다. 주요 변경 사항은 다음과 같습니다.

* **제네릭 개선:** Go 1.18에 처음 도입된 제네릭 기능이 더욱 강력해졌습니다. 
* **새로운 내장 타입:** `any`와 `comparable`라는 새로운 내장 타입이 추가되었습니다.
* **성능 향상:** 특정 작업의 성능을 향상시키는 여러 가지 개선 사항이 포함되어 있습니다.
* **언어 변경:** 몇 가지 언어 변경 사항과 수정 사항이 적용되었습니다.
* **표준 라이브러리 개선:** 몇 가지 새로운 패키지가 추가되었으며, 기존 패키지의 기능이 개선되었습니다.

### Description

Go 1.23은 Go 언어의 안정성과 성능을 향상시키는 데 중점을 둔 릴리즈입니다. 이 릴리즈에는 개발자 경험을 향상시키는 다양한 새로운 기능과 개선 사항이 포함되어 있습니다. 

### Discussion

1. **제네릭 기능 개선:** Go 1.18에서 처음 도입된 제네릭은 Go 1.23에서 더욱 강력해졌습니다. 이제 제네릭은 더욱 다양한 상황에서 사용될 수 있으며, 코드 재사용성을 높이고 유지 보수를 단순화할 수 있습니다.
2. **새로운 내장 타입:** `any`와 `comparable`는 Go 1.23에 추가된 새로운 내장 타입입니다. 이러한 타입은 개발자가 코드를 더 명확하고 간결하게 작성할 수 있도록 도와줍니다.
3. **성능 향상:** Go 1.23은 특정 작업의 성능을 향상시키는 다양한 개선 사항을 포함하고 있습니다. 예를 들어, 컴파일 시간, 실행 시간 및 메모리 사용량이 개선되었습니다.
4. **표준 라이브러리 개선:** Go 1.23은 몇 가지 새로운 패키지를 추가했으며, 기존 패키지의 기능이 개선되었습니다. 예를 들어, 새로운 `unique`, `iter`, `structs` 패키지가 추가되었으며, `time`, `net/http`, `crypto/tls`, `reflect` 등의 패키지에 새로운 기능이 추가되었습니다.

### Features

- **제네릭 개선:** 제네릭 기능을 향상시켜 더 다양한 상황에서 사용 가능하게 되었습니다.
- **새로운 내장 타입:** `any`와 `comparable`라는 새로운 내장 타입이 추가되었습니다.
- **성능 향상:** 특정 작업의 성능을 향상시키는 다양한 개선 사항이 적용되었습니다.
- **언어 변경:** 언어 변경 사항과 수정 사항이 적용되었습니다.
- **표준 라이브러리 개선:** 몇 가지 새로운 패키지가 추가되었으며, 기존 패키지의 기능이 개선되었습니다.

### Usage

#### Installation

Go 1.23은 [Go 웹사이트](https://go.dev/dl/)에서 다운로드할 수 있습니다. 설치 후 `go version` 명령어를 사용하여 설치된 버전을 확인할 수 있습니다.

#### Hello World

```go
package main

import "fmt"

func main() {
    fmt.Println("Hello, World!")
}
```

#### 웹 서버

```go
package main

import (
    "fmt"
    "net/http"
)

func handler(w http.ResponseWriter, r *http.Request) {
    fmt.Fprintf(w, "Hello, %s!", r.URL.Path[1:])
}

func main() {
    http.HandleFunc("/", handler)
    http.ListenAndServe(":8080", nil)
}
```

### Recommendation

Go 1.23은 Go 프로그래밍 언어를 사용하는 모든 개발자에게 권장됩니다. 이 릴리즈는 다양한 새로운 기능과 개선 사항을 제공하여 개발자 경험을 향상시키고 코드의 안정성과 성능을 향상시킵니다.

### External Links

- [Go 1.23 릴리즈 노트](https://go.dev/doc/go1.23)
- [Go 웹사이트](https://go.dev/)

### Caution

- Go 1.23은 이전 버전과의 호환성을 보장하지만, 몇 가지 변경 사항으로 인해 코드에 문제가 발생할 수 있습니다. 릴리즈 노트를 참조하여 코드를 업데이트하고 문제를 해결하십시오.
- Go 1.23은 최신 릴리즈이므로 이전 버전과 비교하여 다양한 기능과 개선 사항을 제공합니다. 하지만 모든 기능이 모든 환경에서 안정적이지 않을 수 있습니다. 따라서 사용 전에 충분히 테스트하고 문제 발생 시 릴리즈 노트를 참조하십시오.
## Go-PDFIUM: Go 언어를 위한 PDF 처리 라이브러리

### 요약

Go-PDFIUM은 Go 언어에서 PDF 문서를 처리할 수 있도록 지원하는 라이브러리입니다. C++로 작성된 PDFIUM 라이브러리를 Go 언어로 바인딩하여 제공하며, PDF 문서의 렌더링, 텍스트 추출, 컨텐츠 수정 등 다양한 기능을 지원합니다.

### 설명

Go-PDFIUM은 Go 언어로 작성된 PDF 문서 처리 라이브러리입니다. Google에서 개발한 고성능 PDF 렌더링 엔진인 PDFIUM을 Go 언어에서 사용할 수 있도록 포팅한 것입니다. 이 라이브러리는 PDF 문서의 렌더링, 텍스트 추출, 컨텐츠 수정, 암호화 및 해독 등의 기능을 제공합니다.

### 토론

1. Go-PDFIUM은 Go 언어에서 사용할 수 있는 다른 PDF 처리 라이브러리에 비해 성능이 뛰어나다는 장점을 가지고 있습니다.
2. PDFIUM은 Google에서 개발한 PDF 렌더링 엔진으로, 다양한 기능을 제공하고 안정성이 높습니다.
3. Go-PDFIUM은 PDF 문서를 처리하는 데 필요한 다양한 기능을 제공하여 개발자의 생산성을 높이고 개발 시간을 단축할 수 있습니다.

### 기능

- PDF 문서 렌더링
- PDF 문서 텍스트 추출
- PDF 문서 컨텐츠 수정
- PDF 문서 암호화 및 해독
- PDF 문서 페이지 관리
- PDF 문서 메타데이터 접근

### 사용

#### 설치

```bash
go get github.com/klippa-app/go-pdfium
```

#### PDF 렌더링

```go
package main

import (
	"fmt"

	"github.com/klippa-app/go-pdfium"
)

func main() {
	// PDF 파일 열기
	pdf, err := pdfium.Open("path/to/your/pdf.pdf")
	if err != nil {
		fmt.Println("Error opening PDF:", err)
		return
	}
	defer pdf.Close()

	// 첫 번째 페이지 렌더링
	page, err := pdf.Page(0)
	if err != nil {
		fmt.Println("Error getting page:", err)
		return
	}
	defer page.Close()

	// 렌더링된 이미지 가져오기
	image, err := page.Render(100, 100) // 100x100 픽셀 크기로 렌더링
	if err != nil {
		fmt.Println("Error rendering page:", err)
		return
	}
	defer image.Close()

	// 이미지 저장 (예: PNG 파일로)
	err = image.Save("rendered.png")
	if err != nil {
		fmt.Println("Error saving image:", err)
		return
	}
}
```

#### 텍스트 추출

```go
package main

import (
	"fmt"

	"github.com/klippa-app/go-pdfium"
)

func main() {
	// PDF 파일 열기
	pdf, err := pdfium.Open("path/to/your/pdf.pdf")
	if err != nil {
		fmt.Println("Error opening PDF:", err)
		return
	}
	defer pdf.Close()

	// 첫 번째 페이지 텍스트 추출
	page, err := pdf.Page(0)
	if err != nil {
		fmt.Println("Error getting page:", err)
		return
	}
	defer page.Close()

	text, err := page.Text()
	if err != nil {
		fmt.Println("Error extracting text:", err)
		return
	}

	// 추출된 텍스트 출력
	fmt.Println(text)
}
```

### 권장 사항

Go-PDFIUM은 Go 언어에서 PDF 문서를 처리하는 데 유용한 라이브러리입니다. PDF 렌더링, 텍스트 추출, 컨텐츠 수정 등의 기능을 제공하여 개발 시간을 단축하고 효율성을 높일 수 있습니다.

### 외부 링크

- Go-PDFIUM GitHub 저장소: [https://github.com/klippa-app/go-pdfium](https://github.com/klippa-app/go-pdfium)
- PDFIUM 문서: [https://pdfium.io/](https://pdfium.io/)

### 주의 사항

- Go-PDFIUM은 PDFIUM 라이브러리에 의존합니다. PDFIUM 라이브러리의 라이선스를 확인하세요.
- Go-PDFIUM은 모든 PDF 문서를 완벽하게 처리할 수 있는 것은 아닙니다. PDF 문서의 구조와 복잡성에 따라 처리에 실패할 수 있습니다. 
## 컴파일러 및 런타임에서 해시 기반 이진 검색 디버깅

### 요약

이 글은 컴파일러 및 런타임에서 코드 변경으로 인한 오류를 해결하는 데 사용되는 해시 기반 이진 검색 디버깅 기법에 대해 설명합니다. 특히, 이 글은 Go 컴파일러에서 개발된 `bisect` 도구를 중심으로 설명하며, 이 도구는 코드 변경을 특정 함수, 라인 또는 콜 스택에 국한하여 문제를 해결하는 데 도움을 줍니다.

### 설명

`bisect` 도구는 이진 검색 알고리즘을 사용하여 프로그램의 위치를 검색합니다. 이를 통해 코드 변경으로 인해 발생하는 오류의 원인을 좁히고 문제 해결을 위한 작업을 간소화할 수 있습니다. `bisect` 도구는 해시 기반 방식을 사용하여 코드 위치를 식별하고, 이를 통해 병렬 컴파일, 스레드 간섭 등 복잡한 상황에서도 효율적으로 작동합니다.

### 논의

1. **이진 검색**:  `bisect` 도구는 이진 검색 알고리즘을 사용하여 프로그램의 위치를 효율적으로 탐색합니다. 이를 통해 잠재적인 문제 코드 영역을 빠르게 좁힐 수 있습니다.
2. **해시 기반 접근**: `bisect` 도구는 해시 기반 방식을 사용하여 코드 위치를 식별합니다. 이는 코드 위치의 순서가 달라져도 동일한 해시 값을 생성하여 병렬 컴파일, 스레드 간섭 등 복잡한 상황에서도 작동할 수 있도록 합니다.
3. **Bisect-Reduce 알고리즘**: `bisect` 도구는 Bisect-Reduce 알고리즘을 사용하여 문제의 원인을 찾습니다. 이 알고리즘은 코드 위치를 재귀적으로 분할하여 문제를 일으키는 최소한의 코드 위치 집합을 찾습니다.

### 기능

- **코드 위치 식별**:  `bisect` 도구는 해시 기반 방식을 사용하여 코드 위치를 식별합니다.
- **Bisect-Reduce 알고리즘 구현**:  `bisect` 도구는 Bisect-Reduce 알고리즘을 구현하여 오류를 일으키는 최소한의 코드 위치 집합을 찾습니다.
- **다양한 환경 지원**: `bisect` 도구는 병렬 컴파일, 스레드 간섭 등 복잡한 환경에서도 작동합니다.
- **사용자 편의성**: `bisect` 도구는 사용하기 쉬운 명령줄 인터페이스를 제공합니다.

### 사용법

#### 설치

```bash
go install golang.org/x/tools/cmd/bisect@latest
```

#### 사용 예시

- Go 1.22 루프 변수 문제 디버깅:

```bash
bisect -compile=loopvar go test
```

- Go 1.23 타이머 문제 디버깅:

```bash
bisect -godebug asynctimerchan=1 go test
```

### 추천

`bisect` 도구는 컴파일러 및 런타임에서 코드 변경으로 인한 오류를 해결하는 데 유용한 도구입니다. 특히 복잡한 프로그램에서 발생하는 문제를 해결할 때 매우 효과적입니다. 

### 외부 링크

- [Python 문서: bisect 모듈](https://docs.python.org/3/library/bisect.html)
- [Wikipedia: 이진 검색](https://ko.wikipedia.org/wiki/%EC%9D%B4%EC%A7%80_%EA%B2%8C%EC%83%89)
- [Go 패키지 문서: bisect](https://pkg.go.dev/golang.org/x/tools/cmd/bisect)
- [Go 블로그: LoopvarExperiment](https://go.dev/blog/loopvar-preview)
- [Go 변경 사항: 타이머 문제](https://go.dev/change/966609ad9e82ba173bcc8f57f4bfc35a86a62c8a)

### 주의 사항

- `bisect` 도구는 해시 기반 방식을 사용하기 때문에 해시 충돌이 발생할 수 있습니다.
- `bisect` 도구는 특정 환경 및 컴파일러에 따라 작동 방식이 다를 수 있습니다.
- `bisect` 도구는 문제 해결을 위한 도구일 뿐이며, 모든 문제를 해결할 수 있는 것은 아닙니다.

## Go에서의 암호화: AES 암호화

### 요약

이 글은 Go의 표준 라이브러리에 포함된 AES(Advanced Encryption Standard) 암호화 시스템의 기본 개념과 사용법을 설명합니다. AES는 최첨단 암호화 시스템이며 Go에서 사용하기 쉽습니다.

### 설명

AES는 데이터를 보호하는 데 널리 사용되는 대칭 블록 암호화 알고리즘입니다. 즉, 암호화와 복호화에 동일한 키를 사용합니다. AES는 미국 정부에서 표준 암호화 알고리즘으로 채택되었으며, 다양한 분야에서 데이터 보안을 위해 사용됩니다.

### 토론

1. **AES 암호화의 강력함**: AES는 강력한 암호화 알고리즘으로 알려져 있으며, 현재까지 해독되지 않았습니다. 
2. **블록 암호화**: AES는 블록 암호화 알고리즘으로, 데이터를 고정된 크기의 블록으로 나누어 암호화합니다. 
3. **대칭 키 암호화**: AES는 대칭 키 암호화를 사용하며, 암호화와 복호화에 동일한 키를 사용합니다.
4. **암호화 모드**: AES는 ECB(Electronic Code Book)와 CBC(Cipher Block Chaining)와 같은 다양한 모드를 지원하며, 각 모드는 고유한 특징과 장단점을 가지고 있습니다.

### 기능

- **강력한 보안**: AES는 강력한 암호화 알고리즘으로 데이터를 안전하게 보호합니다.
- **다양한 블록 크기 지원**: AES는 128비트, 192비트, 256비트 블록 크기를 지원하여 다양한 보안 요구 사항을 충족합니다.
- **다양한 키 길이 지원**: AES는 128비트, 192비트, 256비트 키 길이를 지원하여 보안 수준을 조정할 수 있습니다.
- **GCM 모드**: AES는 GCM(Galois Counter Mode) 모드를 지원하여 암호화와 인증을 동시에 수행할 수 있습니다.

### 사용

#### 설치

Go의 `crypto/aes` 패키지는 표준 라이브러리에 포함되어 있으므로 별도의 설치가 필요하지 않습니다.

#### 암호화

```go
package main

import (
    "crypto/aes"
    "crypto/cipher"
    "crypto/rand"
    "encoding/hex"
    "fmt"
    "io"
    "os"
)

func main() {
    // 암호화 키 생성 (32바이트)
    key := make([]byte, 32)
    if _, err := io.ReadFull(rand.Reader, key); err != nil {
        panic(err)
    }

    // 암호화할 데이터
    plaintext := []byte("비밀 데이터")

    // AES 암호화 객체 생성 (CBC 모드)
    block, err := aes.NewCipher(key)
    if err != nil {
        panic(err)
    }
    iv := make([]byte, aes.BlockSize)
    if _, err := io.ReadFull(rand.Reader, iv); err != nil {
        panic(err)
    }
    enc := cipher.NewCBCEncrypter(block, iv)

    // 암호화
    ciphertext := make([]byte, len(plaintext))
    enc.CryptBlocks(ciphertext, plaintext)

    // 암호화된 데이터 출력
    fmt.Println(hex.EncodeToString(ciphertext))
}
```

#### 복호화

```go
package main

import (
    "crypto/aes"
    "crypto/cipher"
    "encoding/hex"
    "fmt"
    "io"
    "os"
)

func main() {
    // 암호화 키 (32바이트)
    key, _ := hex.DecodeString("your_encryption_key_in_hex")

    // 암호화된 데이터
    ciphertext, _ := hex.DecodeString("your_encrypted_data_in_hex")

    // AES 복호화 객체 생성 (CBC 모드)
    block, err := aes.NewCipher(key)
    if err != nil {
        panic(err)
    }
    iv := ciphertext[:aes.BlockSize]
    ciphertext = ciphertext[aes.BlockSize:]
    dec := cipher.NewCBCDecrypter(block, iv)

    // 복호화
    plaintext := make([]byte, len(ciphertext))
    dec.CryptBlocks(plaintext, ciphertext)

    // 복호화된 데이터 출력
    fmt.Println(string(plaintext))
}
```

### 추천

AES 암호화는 데이터 보안을 위해 널리 사용되는 강력한 알고리즘입니다. 데이터를 안전하게 보호하기 위해 AES 암호화를 사용하는 것을 권장합니다. 특히 GCM 모드를 사용하면 암호화와 인증을 동시에 수행하여 더욱 안전하게 데이터를 보호할 수 있습니다.

### 외부 링크

- [AES 위키피디아 페이지](https://en.wikipedia.org/wiki/Advanced_Encryption_Standard)
- [Go 암호화 패키지 문서](https://pkg.go.dev/crypto)

### 주의

- **키 관리**: AES 암호화 키는 매우 중요하며 안전하게 관리해야 합니다. 키가 유출되면 암호화된 데이터가 해독될 수 있습니다.
- **암호화 모드**: AES 암호화는 다양한 모드에서 사용할 수 있습니다. 각 모드는 고유한 특징을 가지고 있으므로 적절한 모드를 선택하는 것이 중요합니다.
- **nonce**: nonce는 암호화마다 고유해야 하며, 동일한 nonce를 사용하면 보안에 취약해질 수 있습니다.

## 암호화의 올바른 답변: 포스트퀀텀 에디션

### 요약

이 글은 양자 컴퓨팅 시대에 안전한 암호화를 위한 포스트퀀텀 암호화(PQC)에 대한 최신 권장 사항을 제공합니다. 기존의 암호화 체계가 양자 컴퓨터의 위협에 취약한 이유와 PQC가 해결책을 제공하는 방법을 설명하며, 실제 환경에서 PQC를 사용하는 방법과 주의 사항을 다룹니다.

### 설명

양자 컴퓨터의 발전으로 기존의 암호화 알고리즘이 해독될 위험이 커지고 있습니다. 이러한 위협에 대응하기 위해 PQC는 양자 컴퓨터의 공격에도 안전한 새로운 암호화 알고리즘을 개발하고 있습니다. 이 글은 PQC의 작동 방식과 현실적인 적용 가능성, 그리고 PQC 관련 기술 및 주의 사항에 대해 설명합니다.

### 토론

1. **PQC는 어떻게 양자 컴퓨터 공격을 방어할까요?** PQC는 양자 컴퓨터가 쉽게 해독할 수 없는 수학적 문제를 기반으로 설계되어 있습니다.
2. **PQC가 실제 환경에 적용되려면 얼마나 걸릴까요?** PQC 기술은 아직 개발 단계에 있지만, 빠르게 발전하고 있으며, 향후 몇 년 안에 상용화될 것으로 예상됩니다.
3. **PQC는 어떤 분야에 사용될 수 있을까요?** PQC는 데이터 보안, 네트워크 통신, 디지털 서명, 웹 보안 등 다양한 분야에 적용될 수 있습니다.

### 기능

- 양자 컴퓨터에 대한 보안 강화
- 기존 암호화 알고리즘의 취약성 해결
- 안전한 데이터 보호 및 네트워크 통신 보장

### 사용

#### 설치

PQC 알고리즘은 다양한 암호화 라이브러리에 포함되어 있습니다. 사용하려는 PQC 알고리즘에 따라 적절한 라이브러리를 설치해야 합니다.

#### PQC 알고리즘 사용

PQC 알고리즘은 기존의 암호화 알고리즘과 유사한 방식으로 사용할 수 있습니다. 데이터 암호화, 디지털 서명, 키 교환 등 다양한 용도로 사용될 수 있습니다.

### 권장 사항

- PQC는 미래의 데이터 보안을 위한 중요한 기술입니다.
- 양자 컴퓨팅 시대에 대비하여 PQC 기술을 연구하고 적용하는 것이 중요합니다.

### 외부 링크

- [NIST 포스트퀀텀 암호화 표준](https://csrc.nist.gov/projects/post-quantum-cryptography)
- [Open Quantum Safe](https://openquantumsafe.org/)

### 주의 사항

- PQC는 아직 완전히 검증되지 않은 기술이며, 더 많은 연구가 필요합니다.
- PQC 알고리즘을 구현할 때는 신뢰할 수 있는 라이브러리를 사용하는 것이 중요합니다.
- PQC는 기존의 암호화 알고리즘보다 성능이 떨어질 수 있습니다. 
- PQC 관련 기술은 빠르게 발전하고 있으며, 새로운 표준과 알고리즘이 지속적으로 등장할 수 있습니다.

### 추가 정보

- PQC는 양자 컴퓨터가 해독할 수 없는 새로운 수학적 문제를 활용합니다.
- PQC 알고리즘은 종류에 따라 다양한 장단점을 가지고 있습니다.
- PQC의 도입은 데이터 보안의 미래를 위한 필수적인 과정입니다.

### 결론

PQC는 양자 컴퓨팅 시대에 안전한 암호화를 보장하기 위한 중요한 기술입니다. PQC 기술의 발전과 적용을 통해 미래의 데이터 보안 위협에 대비해야 합니다.
## 20년 전 사나이 개발자들의 주석: 유튜브 숏츠 분석

### Summary

이 유튜브 숏츠 영상은 20년 전 개발자들이 코드에 남긴 주석을 보여주며, 당시 개발 문화와 코딩 스타일을 유머러스하게 보여줍니다. 

### Description

"20년 전 사나이 개발자들의 주석"이라는 제목의 이 숏츠 영상은 코딩애플 채널에서 업로드되었습니다. 영상은 20년 전 개발자들이 남긴 주석을 보여주며, 옛날 개발자들의 코딩 스타일과 당시 개발 환경을 엿볼 수 있습니다. 

### Discussion

1. **옛날 개발 문화 반영**: 영상 속 주석은 오늘날의 기준으로는 다소 투박하고 직설적인 표현이 많습니다. 이는 당시 개발 문화가 현재보다 더 자유롭고 개인적인 표현을 허용했던 것을 반영합니다.
2. **개발 언어 변천**: 영상에서 사용된 코드는 옛날 개발 언어로 보입니다. 이는 시간이 지남에 따라 개발 언어가 발전하고 변화해왔음을 보여줍니다.
3. **코딩 스타일 변화**:  20년 전의 주석은 오늘날의 주석과 비교했을 때 더 상세하고 설명적인 경향을 보입니다. 이는 당시 개발자들이 코드를 문서화하는 데 더 중점을 두었던 것을 반영합니다.

### Features

- **유머**: 옛날 개발자들의 코딩 스타일과 주석을 유머러스하게 보여줍니다.
- **추억**: 20년 전 개발 환경을 떠올리게 하는 추억을 불러일으킵니다.
- **개발 문화 비교**: 과거와 현재의 개발 문화를 비교해 볼 수 있는 좋은 자료입니다.

### Recommendation

이 숏츠 영상은 개발자라면 누구나 공감할 수 있는 재미있는 콘텐츠입니다. 옛날 개발 문화와 코딩 스타일을 엿보고 웃음과 함께 추억을 떠올리고 싶다면 꼭 시청해보세요.

### External Links

- [코딩애플 유튜브 채널](https://www.youtube.com/@codingapple)

## Go 맵: 핵심 개념 및 사용법

### 요약

Go 언어의 맵은 키-값 쌍을 저장하는 데 사용되는 데이터 구조입니다. 맵은 해시 테이블을 사용하여 효율적인 검색 및 삽입을 가능하게 합니다. 이 글에서는 Go 맵의 기본적인 사용법과 중요한 기능들을 다룹니다. 맵의 내부 동작 원리, 특히 버킷, 오버플로우 버킷, 해시, 증가적 성장, 배수 성장 등을 자세히 살펴봅니다.

### 설명

Go 맵은 키를 사용하여 값을 저장하고 액세스하는 데 사용되는 데이터 구조입니다. 키는 고유해야 하며 값은 어떤 타입이든 될 수 있습니다. 맵은 순서가 정해져 있지 않으며, 키를 통해 값에 액세스합니다.

### 토론

1. **맵은 어떻게 작동하는가?** Go 맵은 해시 테이블을 사용하여 키를 해시 값으로 변환하고 해시 값을 사용하여 값을 저장합니다. 해시 테이블은 효율적인 검색 및 삽입을 가능하게 합니다.
2. **맵의 장단점은 무엇인가?** 맵은 빠른 검색과 삽입 속도를 제공하지만, 순서가 정해져 있지 않기 때문에 순서대로 데이터를 액세스해야 할 때는 적합하지 않습니다.
3. **맵을 어떻게 사용할 수 있나?** 맵은 다양한 용도로 사용될 수 있습니다. 예를 들어, 사용자 이름을 키로 하고 사용자 정보를 값으로 저장하는 데 사용할 수 있습니다.

### 기능

- 키-값 쌍을 저장할 수 있습니다.
- 키를 사용하여 값에 액세스할 수 있습니다.
- 해시 테이블을 사용하여 효율적인 검색 및 삽입을 제공합니다.

### 사용법

#### 맵 생성

```go
// 맵 선언
var myMap map[string]int

// 맵 초기화
myMap = make(map[string]int)

// 맵 초기화 및 값 설정
myMap = map[string]int{"apple": 1, "banana": 2}
```

#### 값 삽입 및 액세스

```go
// 값 삽입
myMap["orange"] = 3

// 값 액세스
value, ok := myMap["apple"]

// ok는 키가 존재하는지 확인하는 변수
if ok {
  fmt.Println("apple의 값:", value)
} else {
  fmt.Println("apple은 존재하지 않습니다.")
}
```

#### 값 삭제

```go
// 값 삭제
delete(myMap, "banana")
```

### 권장 사항

Go 맵은 빠른 검색 및 삽입 속도를 제공하기 때문에 데이터를 저장하고 액세스하는 데 유용한 데이터 구조입니다.

### 외부 링크

- [Go 공식 문서: 맵](https://go.dev/ref/spec#Map_types)
- [Go 맵에 대한 자세한 설명](https://golangbyexample.com/maps-in-golang/)

### 주의

- 맵의 키는 고유해야 합니다. 동일한 키를 사용하여 값을 삽입하면 기존 값이 덮어쓰여집니다.
- 맵은 순서가 정해져 있지 않기 때문에 순서대로 데이터를 액세스해야 할 때는 적합하지 않습니다.
- 맵에 없는 키로 값을 액세스하면 nil 값이 반환됩니다.
- 맵은 쓰레드 안전하지 않습니다. 동시에 읽고 쓰는 작업을 수행할 때는 주의해야 합니다.

### 추가 설명 (내부 동작)

- **버킷:** 맵은 내부적으로 버킷이라고 불리는 작은 단위로 데이터를 저장합니다. 각 버킷은 최대 8개의 키-값 쌍을 저장할 수 있습니다.
- **오버플로우 버킷:** 버킷이 가득 차면 오버플로우 버킷이 생성됩니다. 오버플로우 버킷은 원래 버킷에 연결되어 추가 데이터를 저장합니다.
- **해시:** 맵은 키의 해시 값을 사용하여 데이터를 버킷에 저장합니다. 해시 값은 키를 숫자로 변환하여 버킷 인덱스를 결정하는 데 사용됩니다.
- **증가적 성장:** 맵이 가득 차면 맵은 새로운 버킷 배열을 할당하여 크기를 늘립니다. 증가적 성장은 성능 저하를 방지하기 위해 점진적으로 수행됩니다.
- **배수 성장:** 맵은 일반적으로 두 배로 크기를 늘립니다. 이렇게 하면 맵의 성능이 유지되고 성능 저하를 최소화할 수 있습니다.

**참고:** 맵의 내부 동작은 Go 버전에 따라 달라질 수 있습니다.
## HTTP Signature를 위한 Go 라이브러리: httpsig

### Summary

httpsig는 Go 언어로 작성된 라이브러리로, HTTP 요청 및 응답에 디지털 서명을 추가하고 검증하는 데 사용됩니다. HTTP Signature Specification(RFC 9421)을 준수하여 API 보안 및 인증 기능을 제공합니다. 

### Description

httpsig는 HTTP 요청 및 응답의 무결성과 출처를 검증하기 위한 디지털 서명을 생성하고 검증하는 기능을 제공하는 Go 라이브러리입니다. 다양한 키, 알고리즘 및 옵션을 지원하여 유연한 보안 설정을 가능하게 합니다. 또한, HTTP 메시지 처리, 키 해결, 난수 생성 및 검사 등 다양한 유틸리티 함수를 제공합니다.

### Discussion

1. **HTTP Signature의 필요성:** HTTP Signature는 API 보안 및 인증에 매우 중요합니다. 서명을 통해 요청 또는 응답의 무결성과 출처를 검증할 수 있으므로, 위변조 및 부인 방지에 효과적입니다.
2. **다양한 키 및 알고리즘 지원:** httpsig는 ECDSA, RSA 및 HMAC 알고리즘을 포함한 다양한 키와 알고리즘을 지원하여, 사용자 환경에 맞는 보안 설정을 구성할 수 있습니다.
3. **다양한 툴과 유틸리티 제공:** httpsig는 요청/응답 처리, 키 생성 및 관리, 난수 생성 및 검사 등 다양한 기능을 제공하는 툴과 유틸리티를 제공하여, HTTP Signature를 사용하는 데 편리함을 더합니다.

### Features

- HTTP Signature 생성 및 검증 기능 제공
- ECDSA, RSA, HMAC 알고리즘 지원
- 사용자 지정 키 및 알고리즘 지원
- 난수 생성 및 검사 기능 제공
- HTTP 메시지 처리, 키 해결, 난수 생성 및 검사 유틸리티 함수 제공
- 서명 협상(Signature Negotiation) 지원

### Usage

#### Installation

```bash
go get github.com/dadrus/httpsig
```

#### HTTP Signature 생성

```go
import (
	"context"
	"crypto/ecdsa"
	"net/http"
	"time"

	"github.com/dadrus/httpsig"
)

// 키 및 알고리즘 설정
keyID := "key1"
privKey := &ecdsa.PrivateKey{} // 개인 키 로딩
algorithm := httpsig.EcdsaP256Sha256

// Signer 생성
signer, err := httpsig.NewSigner(
	httpsig.Key{KeyID: keyID, Key: privKey, Algorithm: algorithm},
	httpsig.WithTTL(5*time.Second),
	httpsig.WithComponents("@authority", "@method", "x-my-fancy-header"),
	httpsig.WithTag("myapp"),
)
// error 처리

// HTTP 요청 생성
req, err := http.NewRequestWithContext(context.Background(), "GET", "https://some-url.com", nil)
// error 처리

// 요청 서명
header, err := signer.Sign(httpsig.MessageFromRequest(req))
// error 처리

// 서명된 헤더를 요청에 추가
req.Header = header
```

#### HTTP Signature 검증

```go
import (
	"net/http"
	"time"

	"github.com/dadrus/httpsig"
)

// 키 해결 함수 (keyResolver)
keyResolver := func(keyID string) (httpsig.Key, error) {
	// 키ID에 해당하는 키를 찾아 반환
	return httpsig.Key{}, nil
}

// 난수 검사 함수 (nonceChecker)
nonceChecker := func(nonce string) (bool, error) {
	// 난수의 유효성을 검사
	return true, nil
}

// Verifier 생성
verifier, err := httpsig.NewVerifier(
	keyResolver,
	httpsig.WithNonceChecker(nonceChecker),
	httpsig.WithRequiredComponents("@authority", "@method", "x-my-fancy-header"),
	httpsig.WithValidityTolerance(5*time.Second),
	httpsig.WithMaxAge(30*time.Second),
	httpsig.WithValidateAllSignatures(),
)
// error 처리

// HTTP 응답 생성
resp, err := http.Get("https://some-url.com")
// error 처리

// 응답 검증
err = verifier.Verify(httpsig.MessageFromResponse(resp))
// error 처리
```

### Recommendation

HTTP Signature를 사용하여 API 보안 및 인증을 강화하고 싶은 Go 개발자에게 추천합니다. 특히, 외부 API와 통신할 때 보안이 중요한 경우 유용하게 사용할 수 있습니다.

### External Links

- [HTTP Signature Specification](https://www.rfc-editor.org/rfc/rfc9421.html)
- [httpsig Github Repository](https://github.com/dadrus/httpsig)

### Caution

- HTTP Signature는 요청 및 응답을 보호하는 강력한 방법이지만, 완벽한 보안 해결책은 아닙니다.
- 키와 비밀번호를 안전하게 관리하는 것이 중요합니다.
- HTTP Signature는 API 서버와 클라이언트 모두에서 구현해야 합니다.
- 서명 협상 기능은 RFC 9421의 권장 사항을 따르므로, 항상 일관성을 유지하고 적절히 구현해야 합니다. 
- httpsig 라이브러리의 다양한 옵션과 설정을 이해하고, 사용자 환경에 맞게 구성하는 것이 중요합니다.

## 처음부터 비디오 인코더 만들기: codec-from-scratch

### Summary

codec-from-scratch는 Go 언어로 간단한 비디오 인코더를 처음부터 구축하는 방법을 보여주는 GitHub 저장소입니다. 이 프로젝트는 비디오 인코딩의 기본 개념을 이해하고 간단한 비디오 인코더를 구현하는 데 도움이 되도록 설계되었습니다. 

### Description

이 저장소는 비디오 인코딩의 핵심 단계인 RGB24에서 YUV420P로의 색상 공간 변환, 런 레ngth 인코딩 (RLE) 및 DEFLATE 압축을 구현하는 Go 코드를 제공합니다. 

### Discussion

1. **비디오 인코딩 학습에 유용한 도구**: 비디오 인코딩의 기본 개념을 배우고 싶은 개발자에게 좋은 학습 자료입니다. 
2. **실제 인코더의 단순화된 버전**: 이 프로젝트는 실제 비디오 인코더의 복잡성을 단순화하여 핵심 개념에 집중할 수 있도록 합니다.
3. **Go 언어로 구현**: Go 언어는 성능과 효율성이 뛰어나 비디오 인코딩에 적합합니다.

### Features

- RGB24에서 YUV420P로의 색상 공간 변환
- 런 레ngth 인코딩 (RLE)
- DEFLATE 압축

### Usage

#### 컴파일 및 실행

```bash
go run main.go
```

#### 컴파일러 테스트

`video.rgb24` 파일을 사용하여 컴파일러를 테스트할 수 있습니다. 

```bash
cat video.rgb24 | go run main.go
```

### Recommendation

비디오 인코딩에 대해 배우고 싶은 사람들에게 Go 언어로 간단한 인코더를 직접 구축해 볼 수 있는 좋은 기회입니다. 

### External Links

- [GitHub 저장소](https://github.com/kevmo314/codec-from-scratch)
- [Go 언어 문서](https://go.dev/doc/)

### Caution

- 이 프로젝트는 간단한 비디오 인코더를 구축하는 데 초점을 맞추고 있으므로 실제 인코더와 비교하여 기능과 성능이 제한적일 수 있습니다.
- 이 프로젝트는 학습 목적으로 제공되며 상업적인 용도로 사용하기에는 적합하지 않을 수 있습니다.
## 화면 모니터링 도구: screenMonitor

### Summary

screenMonitor는 Linux와 Windows에서 사용 가능한 화면 모니터링 도구입니다. 특정 영역의 픽셀 변경을 감지하여 화면 변화를 감지하고 사용자 정의 이벤트를 발생시킵니다. 게임 자동화, 웹 스크래핑, 데스크톱 자동화 등 다양한 분야에서 활용될 수 있습니다.

### Description

screenMonitor는 특정 영역의 픽셀 변경을 감지하여 화면 변화를 감지하는 도구입니다. 다양한 픽셀 변화 감지 알고리즘을 제공하며, 사용자 정의 픽셀 변화 임계값 설정을 지원합니다. 픽셀 변화가 감지되면 사용자 지정 이벤트를 발생시켜, 이벤트를 기반으로 다른 프로그램을 실행하거나 스크립트를 실행할 수 있습니다.

### Discussion

1. **다양한 운영 체제 지원:** screenMonitor는 Linux와 Windows에서 사용 가능하므로 다양한 환경에서 활용할 수 있습니다.
2. **다양한 활용 가능성:** 게임 자동화, 웹 스크래핑, 데스크톱 자동화, 화면 변화에 대한 실시간 알림 등 다양한 분야에서 활용될 수 있습니다.
3. **사용자 정의 기능:** 사용자 정의 픽셀 변화 임계값 설정, 사용자 지정 이벤트 발생 등을 통해 사용자의 요구 사항에 맞는 기능을 구현할 수 있습니다.

### Features

- 픽셀 변화 감지 기능
- 다양한 픽셀 변화 감지 알고리즘 제공
- 사용자 정의 픽셀 변화 임계값 설정
- 사용자 지정 이벤트 발생 기능

### Usage

#### Installation

```bash
go get github.com/tobigiwa/screenMonitor
```

#### 픽셀 변화 감지

```go
package main

import (
	"fmt"
	"github.com/tobigiwa/screenMonitor"
)

func main() {
	// 화면 모니터링 객체 생성
	monitor := screenMonitor.NewScreenMonitor()

	// 모니터링 영역 지정 (왼쪽 상단 좌표, 오른쪽 하단 좌표)
	monitor.SetArea(0, 0, 100, 100)

	// 픽셀 변화 감지 시작
	monitor.Start()

	// 픽셀 변화 감지 시 실행할 함수
	monitor.OnChange(func() {
		fmt.Println("픽셀 변화 감지됨!")
	})

	// 모니터링 종료
	monitor.Stop()
}
```

#### 사용자 지정 이벤트 발생

```go
package main

import (
	"fmt"
	"github.com/tobigiwa/screenMonitor"
)

func main() {
	// 화면 모니터링 객체 생성
	monitor := screenMonitor.NewScreenMonitor()

	// 모니터링 영역 지정 (왼쪽 상단 좌표, 오른쪽 하단 좌표)
	monitor.SetArea(0, 0, 100, 100)

	// 픽셀 변화 감지 시 실행할 함수
	monitor.OnChange(func() {
		// 다른 프로그램 실행 또는 스크립트 실행
		fmt.Println("픽셀 변화 감지됨!")
	})

	// 픽셀 변화 감지 시작
	monitor.Start()
}
```

### Recommendation

screenMonitor는 화면 모니터링을 위한 간단하고 유용한 도구입니다. 다양한 기능을 제공하며 사용자 정의 기능을 통해 사용자의 요구 사항에 맞게 활용할 수 있습니다. 게임 자동화, 웹 스크래핑, 데스크톱 자동화 등 다양한 분야에서 활용해보세요.

### External Links

- [GitHub Repository](https://github.com/tobigiwa/screenMonitor)
- [Documentation](https://github.com/tobigiwa/screenMonitor/blob/main/README.md)

### Caution

- screenMonitor는 시스템 자원을 사용할 수 있으므로, 성능 저하가 발생할 수 있습니다.
- 특정 게임이나 애플리케이션에서는 화면 모니터링이 제한될 수 있습니다.
- screenMonitor를 악의적인 목적으로 사용하는 것은 불법입니다.

## 주의

 - 이 글은 Gemini Flash를 이용하여 생성한 것으로, 사실과 다를 수 있습니다.

## 출처

 - [https://kmcd.dev/posts/grpc-over-http3/](https://kmcd.dev/posts/grpc-over-http3/)
 - [https://medium.com/@hii_mohit/8-essential-tools-for-frontend-developers-in-2024-f2bdefe2f253](https://medium.com/@hii_mohit/8-essential-tools-for-frontend-developers-in-2024-f2bdefe2f253)
 - [https://medium.com/javarevisited/40-must-read-white-papers-to-learn-system-design-and-software-architecture-775c4197f9c8](https://medium.com/javarevisited/40-must-read-white-papers-to-learn-system-design-and-software-architecture-775c4197f9c8)
 - [https://blog.vbang.dk/2024/07/10/seb-tiger-style/](https://blog.vbang.dk/2024/07/10/seb-tiger-style/)
 - [https://blog.bytebytego.com/p/ep118-what-are-the-differences-among](https://blog.bytebytego.com/p/ep118-what-are-the-differences-among)
 - [https://blog.carlana.net/post/2024/golang-reflect-value-seq/](https://blog.carlana.net/post/2024/golang-reflect-value-seq/)
 - [https://github.com/cogentcore/core](https://github.com/cogentcore/core)
 - [https://github.com/guycipher/btree](https://github.com/guycipher/btree)
 - [https://github.com/google/go-tika](https://github.com/google/go-tika)
 - [https://github.com/swig/swig](https://github.com/swig/swig)
 - [https://github.com/jodigiordano/gg](https://github.com/jodigiordano/gg)
 - [https://dev.to/kelvinvmwinuka/echovault-embeddable-redis-alternative-in-go-16a6](https://dev.to/kelvinvmwinuka/echovault-embeddable-redis-alternative-in-go-16a6)
 - [https://josephwoodward.co.uk/2024/08/performance-improvements-unique-package-go-1-23](https://josephwoodward.co.uk/2024/08/performance-improvements-unique-package-go-1-23)
 - [https://blog.alexewerlof.com/p/organization-architecture](https://blog.alexewerlof.com/p/organization-architecture)
 - [https://medium.com/simpplr-technology/microservices-architecture-the-hard-parts-trap-of-distributed-monolith-7d707858aa32](https://medium.com/simpplr-technology/microservices-architecture-the-hard-parts-trap-of-distributed-monolith-7d707858aa32)
 - [https://www.ardanlabs.com/blog/2024/07/building-secure-go-systems-key-management-middleware-and-error-handling-ep-10.html](https://www.ardanlabs.com/blog/2024/07/building-secure-go-systems-key-management-middleware-and-error-handling-ep-10.html)
 - [https://quic.video/](https://quic.video/)
 - [https://www.warpstream.com/blog/tiered-storage-wont-fix-kafka](https://www.warpstream.com/blog/tiered-storage-wont-fix-kafka)
 - [https://github.com/felangga/chiko](https://github.com/felangga/chiko)
 - [https://water.refraction.network/](https://water.refraction.network/)
 - [https://github.com/refraction-networking/utls](https://github.com/refraction-networking/utls)
 - [https://github.com/awnumar/memguard](https://github.com/awnumar/memguard)
 - [https://github.com/salrashid123/golang-jwt-tpm](https://github.com/salrashid123/golang-jwt-tpm)
 - [https://discuss.secdim.com/t/do-not-use-string-to-store-secret-it-gets-disclosed/247](https://discuss.secdim.com/t/do-not-use-string-to-store-secret-it-gets-disclosed/247)
 - [https://withinboredom.info/2024/08/12/optimizing-cgo-handles/](https://withinboredom.info/2024/08/12/optimizing-cgo-handles/)
 - [https://github.com/lemon-mint/softblake3](https://github.com/lemon-mint/softblake3)
 - [https://go.dev/doc/go1.23](https://go.dev/doc/go1.23)
 - [https://github.com/klippa-app/go-pdfium](https://github.com/klippa-app/go-pdfium)
 - [https://research.swtch.com/bisect](https://research.swtch.com/bisect)
 - [https://bitfieldconsulting.com/posts/aes-encryption](https://bitfieldconsulting.com/posts/aes-encryption)
 - [https://www.latacora.com/blog/2024/07/29/crypto-right-answers-pq/](https://www.latacora.com/blog/2024/07/29/crypto-right-answers-pq/)
 - [https://youtube.com/shorts/p0pGZqC-wUU?si=Cm5SqylFoblH0wtK](https://youtube.com/shorts/p0pGZqC-wUU?si=Cm5SqylFoblH0wtK)
 - [https://victoriametrics.com/blog/go-map/](https://victoriametrics.com/blog/go-map/)
 - [https://github.com/dadrus/httpsig](https://github.com/dadrus/httpsig)
 - [https://github.com/kevmo314/codec-from-scratch](https://github.com/kevmo314/codec-from-scratch)
 - [https://github.com/tobigiwa/screenMonitor](https://github.com/tobigiwa/screenMonitor)
